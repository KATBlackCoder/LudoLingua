# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- **Phase 10.1.19: System.json ID Reconstruction Fix - COMPLETED ✅**
  - **ID Mismatch Resolution:** Fixed critical issue where System.json translation injection was failing
    - **Root Cause Analysis:** Identified mismatch between extraction IDs and reconstruction IDs in `reconstruct_text_unit_id()` function
    - **Extraction vs Reconstruction:** Extraction created IDs like `"system_basic_term_0"` but reconstruction created `"system_terms.basic[0]"`
    - **Injection Failure:** Injection functions expected extraction format but received reconstruction format, causing translations to be ignored
    - **Solution Implementation:** Updated reconstruction logic to generate IDs that match injection expectations
  - **Comprehensive Field Type Handling:** Enhanced `reconstruct_text_unit_id()` function for all System.json field types
    - **Terms Handling:** Added specific parsing for `terms.basic[index]`, `terms.commands[index]`, `terms.params[index]`, `terms.messages.key`
    - **Array Field Handling:** Added parsing for `armorTypes[index]`, `elements[index]`, `equipTypes[index]`, `skillTypes[index]`
    - **Simple Field Handling:** Added handling for `gameTitle` and `currencyUnit` fields
    - **Fallback Support:** Added fallback for other System.json fields with `system_{field}` format
  - **ID Reconstruction Logic:** Implemented intelligent field type parsing and ID generation
    - **Pattern Recognition:** Uses regex patterns to extract indices from field types like `terms.basic[0]`
    - **Index Extraction:** Properly extracts numeric indices from bracketed field types
    - **Key Extraction:** Extracts keys from `terms.messages.key` format for message terms
    - **Consistent Formatting:** Generates IDs in exact format expected by injection functions
  - **Cross-Engine Compatibility:** Ensured fix applies to all RPG Maker engines
    - **MV Engine:** Fix applies to RPG Maker MV System.json handling
    - **MZ Engine:** Fix applies to RPG Maker MZ System.json handling
    - **Consistent Behavior:** All engines now properly handle System.json ID reconstruction
    - **Future-Proof:** Architecture supports any new engines that use System.json format
  - **Benefits Achieved:** Professional-grade System.json translation injection functionality
    - **Working Injection:** System.json translations now properly injected back into game files
    - **Complete Coverage:** All System.json field types supported for translation injection
    - **Consistent Architecture:** ID reconstruction follows same patterns as other RPG Maker files
    - **User Experience:** Users can now successfully translate and export System.json content
    - **Professional Quality:** System.json fully integrated with complete translation workflow

### Fixed
- **System.json Translation Injection:** Fixed critical bug where System.json translations were not being injected back into game files
  - **ID Reconstruction:** Updated `reconstruct_text_unit_id()` function in `src-tauri/src/engines/rpg_maker_mv/engine.rs` to properly handle System.json field types
  - **Field Type Parsing:** Added intelligent parsing for complex field types like `terms.basic[0]:www/data/System.json:0`
  - **Cross-Engine Support:** Fix applies to both RPG Maker MV and MZ engines for consistent behavior

- **Phase 10.1.18: RPG Maker MZ System.json Architecture Alignment - COMPLETED ✅**
  - **Serde Field Mapping Fix:** Added proper serde rename attributes to match JSON field names
    - **Field Mapping:** Added `#[serde(rename)]` attributes for gameTitle, currencyUnit, armorTypes, equipTypes, skillTypes, weaponTypes
    - **JSON Compatibility:** MZ System struct now properly maps to actual JSON field names
    - **Cross-Engine Consistency:** MZ system.rs now matches MV architecture patterns
    - **Parse Reliability:** Eliminates potential JSON parsing issues due to field name mismatches
  - **Non-Translatable Fields Commenting:** Commented out fields that should not be translated
    - **Field Classification:** Commented out weaponTypes, elements, switches, variables in struct definition
    - **Extraction Logic:** Commented out extraction code for non-translatable fields
    - **Injection Logic:** Commented out injection code for non-translatable fields
    - **Architecture Clarity:** Clear separation between translatable and non-translatable fields
  - **Translatable Fields Specification:** Implemented exact field specification as requested
    - **Specified Fields:** Only armorTypes, equipTypes, gameTitle, skillTypes, and terms are extracted
    - **Currency Unit:** Included currencyUnit as it contains UI text (not explicitly specified but UI-relevant)
    - **Terms Structure:** Proper extraction of terms.basic, terms.commands, terms.params, terms.messages
    - **Quality Control:** Ensures only meaningful content is sent for translation
  - **LudoLingua Signature Integration:** Added signature to game title translations
    - **Signature Format:** Game titles now formatted as `"[Translated Title] - Translated by LudoLingua"`
    - **MV Consistency:** Matches the signature behavior implemented in MV system.rs
    - **Brand Recognition:** Provides proper attribution for LudoLingua translations
    - **Professional Quality:** Maintains consistent branding across all engine implementations
  - **Architecture Benefits:** Enhanced maintainability and consistency
    - **Code Consistency:** MZ system.rs now follows same patterns as MV system.rs
    - **Field Clarity:** Clear documentation of which fields are translatable vs non-translatable
    - **Maintainability:** Easier to understand and modify System.json handling
    - **Cross-Engine:** Consistent behavior between MV and MZ engines
  - **Benefits Achieved:** Professional-grade MZ System.json handling
    - **Correct Field Extraction:** Only extracts the fields specified as translatable
    - **Proper JSON Mapping:** Serde attributes ensure correct JSON parsing
    - **Brand Consistency:** LudoLingua signature on translated game titles
    - **Architecture Alignment:** MZ system.rs matches MV architecture patterns
    - **Quality Assurance:** Clear separation between translatable and non-translatable content
- **Phase 10.1.17: System.json Extraction/Injection Fixes - COMPLETED ✅**
  - **Field Type Format Fix:** Corrected field type format to include www/ prefix for proper engine compatibility
    - **Format Standardization:** Changed all field types from `"field:data/System.json:0"` to `"field:www/data/System.json:0"`
    - **Engine Compatibility:** Now matches expected format for engine's reconstruction logic
    - **Consistent Pattern:** Applied to all System.json fields (gameTitle, currencyUnit, armorTypes, elements, equipTypes, skillTypes, weaponTypes, terms)
    - **Cross-Engine Support:** Ensures proper field type recognition across all RPG Maker engines
  - **Weapon Types Extraction Fix:** Enabled and fixed weapon types extraction with proper field usage
    - **Bug Resolution:** Fixed critical bug where `system.game_title.clone()` was used instead of `weapon_type.clone()`
    - **Extraction Enablement:** Uncommented weapon types extraction to process all weapon type names
    - **Proper Field Usage:** Now correctly extracts weapon type names for translation
    - **Translation Support:** Weapon types can now be translated with appropriate prompt types
  - **Switches and Variables Extraction:** Enabled extraction of switches and variables with intelligent filtering
    - **Technical Content Filtering:** Added helper functions to filter out technical switches and variables
    - **Smart Detection:** Filters out debug switches, test variables, coordinate data, and system variables
    - **Content Quality:** Prevents translation of technical content that shouldn't be translated
    - **Comprehensive Coverage:** Handles Japanese debug markers, test patterns, and system variables
  - **Helper Functions Implementation:** Added comprehensive filtering functions for technical content
    - **Switch Filtering:** `is_technical_switch_name()` filters debug switches, test patterns, and empty names
    - **Variable Filtering:** `is_technical_variable_name()` filters system variables, coordinates, and technical data
    - **Pattern Recognition:** Detects Japanese debug markers, test patterns, and system variables
    - **Quality Assurance:** Ensures only meaningful content is sent for translation
  - **Injection Code Updates:** Updated injection methods to handle all new fields properly
    - **Weapon Types Injection:** Added proper injection logic for weapon types with translated text
    - **Switches Injection:** Added injection logic for switches with proper field mapping
    - **Variables Injection:** Added injection logic for variables with proper field mapping
    - **Consistent Pattern:** All injection methods follow the same pattern as other RPG Maker files
  - **Benefits Achieved:** Complete System.json translation support with professional-grade functionality
    - **Comprehensive Coverage:** All System.json translatable content now properly extracted and injected
    - **Quality Control:** Intelligent filtering prevents translation of technical content
    - **Consistent Architecture:** Follows same patterns as other RPG Maker files for maintainability
    - **Professional Quality:** System.json now fully integrated with translation workflow
    - **User Experience:** Users can translate game titles, UI elements, switches, and variables
- **Phase 10.1.16: Clipboard Functionality Refactoring - COMPLETED ✅**
  - **ModalFooter.vue Clipboard Integration:** Centralized clipboard functionality in ModalFooter component
    - **useClipboard Integration:** Added useClipboard composable directly to ModalFooter.vue for centralized clipboard handling
    - **Dynamic Button State:** Implemented reactive button properties that change based on clipboard state (copied/copying)
    - **CopyText Prop:** Added copyText prop to receive text to copy from parent components
    - **Event Handling:** Automatic clipboard operation without requiring parent component intervention
  - **Modal.vue Clipboard Support:** Enhanced Modal component with clipboard functionality
    - **Props Integration:** Added copyText prop and passed through to ModalFooter component
    - **Event Forwarding:** Proper event forwarding from Modal to ModalFooter for clipboard operations
    - **API Consistency:** Maintained consistent Modal API while adding clipboard capabilities
  - **Component Refactoring:** Updated parent components to use centralized clipboard functionality
    - **TranslationEditor.vue:** Removed duplicate clipboard logic and use copyText prop instead
    - **GlossaryForm.vue:** Simplified copy functionality by using Modal's built-in clipboard handling
    - **Code Reduction:** Eliminated duplicate useClipboard imports and clipboard handling logic
  - **Benefits Achieved:** Professional-grade clipboard functionality with DRY principles
    - **Code Reusability:** All modals using copy functionality leverage the same centralized implementation
    - **Consistency:** Clipboard behavior consistent across all modal components with same visual feedback
    - **Maintainability:** Changes to clipboard functionality only need to be made in ModalFooter.vue
    - **User Experience:** Consistent copy button behavior with dynamic state feedback (label, color, icon changes)
    - **Clean Architecture:** Clear separation of concerns with Modal handling clipboard operations internally
- **Phase 10.1.15: GlossaryForm.vue Modal Migration - COMPLETED ✅**
  - **Modal Component Migration:** Successfully migrated GlossaryForm.vue to use shared Modal.vue component
    - **Component Replacement:** Replaced custom UModal structure with shared Modal.vue component for consistency
    - **Two-Column Layout:** Implemented two-column layout with source term and target term cards
    - **Configuration Integration:** Added configuration section with category, language, and enabled settings
    - **Custom Content Slots:** Used custom content slots for specialized glossary functionality
  - **Modal Configuration:** Leveraged built-in modal behavior and keyboard shortcuts
    - **Header Configuration:** Set header icon, colors, and background for glossary context
    - **Status Integration:** Used category and language metadata for status display
    - **Footer Configuration:** Configured save/cancel buttons with proper validation
    - **Keyboard Shortcuts:** Leveraged built-in Ctrl/Cmd + Enter to save functionality
  - **Code Quality Improvements:** Enhanced maintainability and consistency
    - **Eliminated Duplication:** Removed custom modal structure from GlossaryForm.vue
    - **Centralized Logic:** Modal behavior now centralized in shared Modal.vue component
    - **Better Encapsulation:** Modal component handles all modal-related functionality
    - **Reusability:** Other forms using Modal can access the same modal behavior
  - **Benefits Achieved:** Professional-grade modal component integration
    - **Code Reusability:** GlossaryForm.vue now uses shared Modal component
    - **Consistency:** Modal behavior consistent across all form components
    - **Maintainability:** Changes to modal logic only need to be made in Modal.vue
    - **Type Safety:** Full TypeScript support with proper modal configuration
    - **Clean Architecture:** Clear separation of concerns with Modal handling modal behavior
- **Phase 10.1.14: TranslationForm.vue Modal Migration - COMPLETED ✅**
  - **Modal Component Migration:** Successfully migrated TranslationForm.vue to use shared Modal.vue component
    - **Component Replacement:** Replaced custom UModal structure with shared Modal.vue component for consistency
    - **Two-Column Layout:** Implemented two-column layout with source text and translation form cards
    - **Metadata Integration:** Added metadata section with status, file path, and field type using MetadataCard
    - **Custom Slots:** Used translationContent and metadataFooter slots for specialized functionality
  - **Status Utilities Encapsulation:** Moved status utilities to Modal.vue for better component architecture
    - **Utility Migration:** Moved getStatusLabel, getStatusColor, and statusOptions from utils/translation to Modal.vue
    - **defineExpose Integration:** Exposed utilities through Modal.vue's defineExpose for parent component access
    - **Template Ref Access:** Used template ref to access Modal's exposed utilities in TranslationForm.vue
    - **Type Safety:** Maintained full TypeScript support with proper fallbacks for utility access
  - **Code Quality Improvements:** Enhanced maintainability and consistency
    - **Eliminated Duplication:** Removed local status utility definitions from TranslationForm.vue
    - **Centralized Logic:** Status utilities now centralized in Modal.vue for reuse across components
    - **Better Encapsulation:** Modal component owns its related utilities for cleaner architecture
    - **Reusability:** Other forms using Modal can access the same status utilities
  - **Benefits Achieved:** Professional-grade modal component integration
    - **Code Reusability:** TranslationForm.vue now uses shared Modal component and utilities
    - **Consistency:** Status utilities consistent across all modal components
    - **Maintainability:** Changes to status logic only need to be made in Modal.vue
    - **Type Safety:** Full TypeScript support with proper utility access patterns
    - **Clean Architecture:** Clear separation of concerns with Modal handling its own utilities
- **Phase 10.1.13: Modal Component Analysis & Implementation Planning - COMPLETED ✅**
  - **Comprehensive Modal Analysis:** Analyzed all three existing modal components for compatibility with new Modal.vue architecture
    - **TranslationEditor.vue Analysis:** Perfect match for two-column layout with source text and translation form cards
    - **TranslationForm.vue Analysis:** Perfect match for two-column layout with metadata integration and status management
    - **GlossaryForm.vue Analysis:** Perfect match for two-column layout with configuration sections and language settings
    - **Implementation Strategy:** All components can be replaced using Modal.vue with custom content slots and props
  - **Architecture Compatibility:** Confirmed perfect compatibility between existing modals and new shared architecture
    - **Two-Column Layout:** All existing modals use two-column layout that matches Modal.vue's built-in support
    - **Card Structure:** Source/translation cards map perfectly to TextCard and FormCard components
    - **Metadata Integration:** Status, category, and configuration data can use MetadataCard component
    - **Custom Content:** Re-translate buttons, prompt type selection, and configuration forms can use custom slots
  - **Migration Benefits:** Identified significant benefits from modal component migration
    - **Code Reduction:** Eliminate 3x modal structure duplication across form components
    - **Consistency:** Standardized modal behavior with shared components and built-in features
    - **Maintainability:** Centralized modal logic makes updates and bug fixes easier
    - **Performance:** Optimized components with proper reactive state management
    - **Accessibility:** Built-in accessibility features ensure inclusive design across all modals
  - **Implementation Plan:** Created detailed migration strategy for each modal component
    - **TranslationEditor.vue:** Use two-column layout with custom content slots for re-translate functionality
    - **TranslationForm.vue:** Use two-column layout with metadata integration for status and file information
    - **GlossaryForm.vue:** Use two-column layout with configuration sections for category and language settings
    - **Custom Slots:** Leverage Modal.vue's slot system for specialized functionality in each component
- **Phase 10.1.12: Modal Supporting Components Creation - COMPLETED ✅**
  - **Modal Component Architecture:** Created comprehensive modal component system in `components/shared/modal/`
    - **ModalHeader.vue:** Standardized modal header with icon, title, description, and actions slot
    - **ModalActions.vue:** Badge display component for status, category, and metadata with customizable colors
    - **ModalBody.vue:** Modal body with loading states, error handling, and content slots
    - **ModalFooter.vue:** Standardized footer with save/cancel buttons, status info, and keyboard shortcuts
    - **TextCard.vue:** Reusable text display card with character count, styling, and validation
    - **FormCard.vue:** Reusable form input card with validation states and error handling
    - **MetadataCard.vue:** Reusable metadata display card for configuration sections
  - **Component Features:** Each component provides comprehensive functionality
    - **Consistent Styling:** All components follow Nuxt UI v4 design patterns with proper theming
    - **Loading States:** Built-in loading indicators with customizable messages and spinners
    - **Error Handling:** Comprehensive error display with alerts and validation feedback
    - **Accessibility:** Proper ARIA labels, keyboard navigation, and screen reader support
    - **Type Safety:** Full TypeScript support with proper interfaces and type checking
    - **Flexibility:** Extensive props system for customization and different use cases
  - **Benefits Achieved:** Professional-grade modal component foundation
    - **Code Reusability:** Shared components eliminate modal duplication across form components
    - **Consistency:** Standardized modal behavior and styling across entire application
    - **Maintainability:** Centralized modal logic makes updates and bug fixes easier
    - **Accessibility:** Built-in accessibility features ensure inclusive design
    - **Performance:** Optimized components with proper reactive state management
    - **Developer Experience:** Clear component APIs with comprehensive TypeScript support
- **Phase 10.1.11: GlossaryTable.vue Refactoring - COMPLETED ✅**
  - **GlossaryTable.vue DataTable Migration:** Successfully migrated GlossaryTable.vue to use shared DataTable component
    - **Component Replacement:** Replaced custom table implementation with DataTable.vue for consistency and maintainability
    - **Feature Integration:** Added pagination, row count, stats, and proper table configuration using DataTable features
    - **Custom Cell Rendering:** Maintained custom status badges and text display with proper slot integration
    - **Type Safety:** Fixed TypeScript issues with proper type casting for row data access
  - **Language Filter Optimization:** Removed redundant source/target language filters for better UX
    - **Filter Removal:** Eliminated `:show-source-language-filter` and `:show-target-language-filter` props
    - **UX Improvement:** Removed confusing language filters since glossary already filters by current language settings
    - **Code Simplification:** Removed unused language filter options and related computed properties
    - **User Clarity:** Added informational alert in AboutGlossary.vue explaining language-specific filtering behavior
  - **Button Color Enhancement:** Improved visual hierarchy with semantic button colors
    - **Reload Button:** Changed from neutral to info color for better visual distinction
    - **Export Button:** Changed from neutral to success color to indicate positive action
    - **Import Button:** Changed from neutral to warning color to indicate data modification
    - **Visual Consistency:** Better color coding for different action types
  - **Benefits Achieved:** Modern, maintainable component architecture with optimized UX
    - **Code Reusability:** Uses shared DataTable component and utility functions
    - **Consistency:** Status and prompt type styling matches other components across application
    - **Performance:** Optimized table functionality with shared DataTable component
    - **Maintainability:** Changes to table functionality only need to be made in DataTable.vue
    - **Better UX:** Removed confusing filters and improved visual hierarchy with semantic colors
    - **Cleaner Code:** Reduced complexity and eliminated duplicate functionality
- **Phase 10.1.10: Text Length Filter AI Error Capping - COMPLETED ✅**
  - **AI Error Outlier Detection:** Identified and resolved 17,274+ character AI translation errors
    - **Root Cause Analysis:** Identified that AI was generating massive reasoning loops instead of simple translations
    - **Error Example:** AI generated 17,274+ character "translation" for simple `【口】開き笑い` input
    - **Problem Impact:** Slider maximum was set to 17,274 characters making it impractical for normal use
    - **Solution Implementation:** Added intelligent capping to prevent AI error outliers from affecting UI
  - **Smart Maximum Capping:** Implemented reasonable maximum limit for text length slider
    - **Dynamic Calculation:** Maintained dynamic calculation based on actual data lengths
    - **Intelligent Capping:** Added `Math.min()` to cap maximum at 1,000 characters for practical UI usage
    - **Error Prevention:** Prevents AI reasoning loops from setting unrealistic slider ranges
    - **User Experience:** Slider now has practical maximum range for normal translation filtering
  - **TranslationResult.vue Enhancement:** Updated maxTextLength calculation with outlier protection
    - **Code Implementation:** Added `Math.min(Math.max(maxSourceLength, maxTranslatedLength, 200), 1000)` logic
    - **Practical Range:** Slider maximum now capped at 1,000 characters instead of 17,274+
    - **Maintained Functionality:** Dynamic calculation still works for normal data while preventing outliers
    - **Performance:** No impact on normal operation, only affects extreme AI error cases
  - **Benefits Achieved:** Practical and usable text length filtering
    - **Usable Interface:** Text length slider now has reasonable maximum range for practical filtering
    - **AI Error Protection:** Prevents AI reasoning loops from breaking UI functionality
    - **Maintained Flexibility:** Dynamic calculation still adapts to actual project data
    - **Better UX:** Users can effectively filter by text length without encountering impractical ranges
    - **Error Recovery:** System gracefully handles AI translation errors without breaking UI
- **Phase 10.1.9: TranslationResult.vue Refactoring - COMPLETED ✅**
  - **TranslationResult.vue DataTable Migration:** Successfully migrated TranslationResult.vue to use shared DataTable component
    - **Component Replacement:** Replaced custom table implementation with DataTable.vue for consistency and maintainability
    - **Feature Integration:** Added pagination, row count, stats, and proper table configuration using DataTable features
    - **Custom Cell Rendering:** Maintained custom status badges and text display with proper slot integration
    - **Type Safety:** Fixed TypeScript issues with proper type casting for row data access
  - **TranslationResult.vue Utility Functions Integration:** Replaced custom functions with shared utility functions
    - **Status Color Mapping:** Replaced custom `statusColor` function with `getBadgeColor` from utils/ui.ts
    - **Icon Mapping:** Replaced custom `getStatusIcon` function with `getStatusIcon` from utils/ui.ts
    - **Code Reduction:** Eliminated ~50 lines of duplicate function definitions
    - **Consistency:** Status colors and icons now consistent across entire application
  - **TranslationResult.vue Filter Logic Simplification:** Streamlined filtering system using DataTable's built-in capabilities
    - **Custom Filter Function:** Implemented custom filter function for placeholder type and text length filtering
    - **Bulk Actions Integration:** Added bulk actions for re-translation and revert operations
    - **Event Handling:** Proper event handling for selection changes and bulk actions
    - **Code Simplification:** Reduced component complexity by removing duplicate table logic
  - **TranslationResult.vue Code Quality Improvements:** Enhanced maintainability and performance
    - **Removed Duplicate Code:** Eliminated custom table implementation and pagination logic
    - **Shared Architecture:** Now uses same DataTable component as other table components
    - **Better Performance:** Leverages DataTable's optimized table functionality
    - **Cleaner Code:** Reduced complexity and improved maintainability
  - **Benefits Achieved:** Modern, maintainable component architecture
    - **Code Reusability:** Uses shared DataTable component and utility functions
    - **Consistency:** Status and prompt type styling matches other components across application
    - **Performance:** Optimized table functionality with shared DataTable component
    - **Maintainability:** Changes to table functionality only need to be made in DataTable.vue
    - **Cleaner Code:** Reduced complexity and eliminated duplicate functionality
- **Phase 10.1.8: TranslationProcess.vue & TranslationRaw.vue Refactoring - COMPLETED ✅**
  - **TranslationProcess.vue DataTable Migration:** Successfully migrated TranslationProcess.vue to use shared DataTable component
    - **Component Replacement:** Replaced custom table implementation with DataTable.vue for consistency and maintainability
    - **Feature Integration:** Added pagination, row count, stats, and sticky headers using DataTable features
    - **Custom Cell Rendering:** Maintained custom status badges and text display with proper slot integration
    - **Type Safety:** Fixed TypeScript issues with proper type casting for row data access
  - **TranslationProcess.vue Utility Functions Integration:** Replaced custom functions with shared utility functions
    - **Status Color Mapping:** Replaced custom `statusColor` function with `getBadgeColor` from utils/ui.ts
    - **Icon Mapping:** Replaced custom `getStatusIcon` function with `getStatusIcon` from utils/ui.ts
    - **Code Reduction:** Eliminated ~30 lines of duplicate function definitions
    - **Consistency:** Status colors and icons now consistent across entire application
  - **TranslationProcess.vue Fullscreen Logic Removal:** Cleaned up unnecessary fullscreen detection and responsive logic
    - **Window Resize Handler Removal:** Eliminated window resize event listeners and lifecycle hooks
    - **Fixed Text Width:** Simplified to fixed `max-w-md` width for text columns
    - **Performance Improvement:** Removed unnecessary event listeners and reactive state
    - **Code Simplification:** Reduced component complexity by removing unused functionality
  - **TranslationProcess.vue Filter Options Removal:** Removed unnecessary filter functionality for progress display
    - **Disabled Filters:** Set `:show-filters="false"` and `:show-search="false"` for focused progress view
    - **Removed Filter Configuration:** Eliminated status filter options and related computed properties
    - **Cleaner Interface:** Users can focus on translation progress without filter distractions
    - **Simplified Code:** Removed unused filter configuration and options
  - **TranslationRaw.vue DataTable Migration:** Successfully migrated TranslationRaw.vue to use shared DataTable component
    - **Component Replacement:** Replaced custom table implementation with DataTable.vue for consistency and maintainability
    - **Feature Integration:** Added pagination, row count, and proper table configuration using DataTable features
    - **Custom Cell Rendering:** Maintained custom prompt type badges and text display with proper slot integration
    - **Type Safety:** Fixed TypeScript issues with proper type casting for row data access
  - **TranslationRaw.vue Utility Functions Integration:** Replaced custom functions with shared utility functions
    - **Prompt Type Color Mapping:** Used `getPromptTypeColor` from utils/table.ts for consistent badge colors
    - **Code Reduction:** Eliminated duplicate function definitions by using shared utilities
    - **Consistency:** Prompt type colors now consistent across entire application
  - **Benefits Achieved:** Modern, maintainable component architecture for both components
    - **Code Reusability:** Both components use shared DataTable component and utility functions
    - **Consistency:** Status and prompt type styling matches other components across application
    - **Performance:** Eliminated unnecessary event listeners and reactive state
    - **Maintainability:** Changes to table functionality only need to be made in DataTable.vue
    - **Cleaner Code:** Reduced complexity and eliminated duplicate functionality
- **Phase 10.1.6: Legacy Component Cleanup - COMPLETED ✅**
  - **TranslationTable.vue Removal:** Removed legacy TranslationTable.vue component that was superseded by modern TranslationView.vue
    - **Architecture Modernization:** TranslationTable.vue used custom UTable implementation while TranslationView.vue uses shared DataTable.vue
    - **Code Reduction:** Eliminated 490 lines of duplicate table logic that was reimplementing DataTable functionality
    - **Consistency Improvement:** Ensures all translation management uses the same modern table architecture
    - **Maintenance Simplification:** Reduces code duplication and maintenance burden by consolidating table implementations
  - **Documentation Updates:** Updated all references across CHANGELOG.md, PROGRESS.MD, TODO.md, and ROADMAP.md
    - **Reference Cleanup:** Updated all mentions of TranslationTable.vue to TranslationView.vue in documentation
    - **Task Completion:** Marked TranslationTable.vue refactoring tasks as completed in TODO.md
    - **Roadmap Update:** Updated Phase 10.2 roadmap to reflect component removal
    - **Progress Tracking:** Updated development metrics to show TranslationTable.vue removal as completed
  - **Benefits Achieved:** Cleaner codebase with modern architecture
    - **Eliminated Duplication:** Removed 490 lines of duplicate table implementation code
    - **Consistent UX:** All translation tables now use the same DataTable.vue architecture
    - **Better Maintainability:** Changes to table functionality only need to be made in DataTable.vue
    - **Modern Patterns:** All components now follow the Phase 10.1 refactored architecture
    - **Reduced Complexity:** Simplified component structure with shared functionality
- **Phase 10.1.7: Project Deletion UI Fix - COMPLETED ✅**
  - **Project Options Watcher:** Added intelligent watcher to monitor project filter options changes in DataTable
    - **Automatic Filter Reset:** When project options are updated after deletion, filter automatically resets if selected project is no longer available
    - **State Synchronization:** Ensures DataTable's internal `projectFilter` state stays synchronized with updated project options
    - **Race Condition Prevention:** Prevents race conditions between filter reset and options reload
    - **User Experience:** Deleted projects disappear immediately from dropdown without requiring app restart
  - **Enhanced Deletion Flow:** Improved project deletion sequencing with proper state management
    - **Immediate Filter Reset:** DataTable resets `projectFilter` to 'All' immediately after successful deletion
    - **NextTick Integration:** Uses `await nextTick()` to ensure filter reset completes before emitting events
    - **Proper Event Emission:** Emits `project-deleted` event only after filter is reset for clean state management
    - **Selection Clearing:** Clears table selections and row selection state during deletion process
  - **TranslationView Integration:** Enhanced data reload process with better error handling and sequencing
    - **Database Delay:** Added 100ms delay to ensure database operations complete before reloading options
    - **Sequential Loading:** Proper sequencing of `loadProjectOptions()` then `loadTranslations()` for consistent state
    - **Error Handling:** Comprehensive error handling with user-friendly error messages and logging
    - **Selection Management:** Clears table selections after data reload to prevent stale selection state
  - **Benefits Achieved:** Professional-grade project deletion functionality
    - **Immediate UI Updates:** Deleted projects disappear instantly without app restart requirement
    - **Robust State Management:** Multiple safeguards ensure filter state stays synchronized with database
    - **Better User Experience:** Clear visual feedback that deletion was successful with immediate UI updates
    - **Error Recovery:** Proper error handling and logging for debugging and user feedback
    - **Race Condition Prevention:** Proper sequencing prevents UI inconsistencies during deletion process
- **Phase 10.1.5: Row Selection Data Mapping Fix - COMPLETED ✅**
  - **Row Selection Data Mapping Fix:** Fixed critical issue where row selection was working but returning empty arrays instead of actual selected row data
    - **Root Cause Analysis:** Identified that TanStack Table uses row indices as keys, not actual row IDs, and the selection mapping was incorrectly trying to map keys back to data
    - **TanStack Table API Integration:** Updated DataTable.vue to use `tableRef.value?.tableApi?.getFilteredSelectedRowModel().rows` to get actual selected rows instead of manual key mapping
    - **Consistent Pattern Implementation:** Applied the same approach used in TranslationView.vue for reliable row selection data retrieval
    - **Selection Count Fix:** Updated selectedCount computation to use TanStack Table API for accurate row counting
    - **Event Handling Enhancement:** Fixed selection change watcher to properly emit actual row data objects instead of empty arrays
  - **DataTable Component Enhancement:** Improved row selection functionality with proper data mapping
    - **API-Based Selection:** Uses TanStack Table's built-in selection API for reliable row data access
    - **Proper Row Mapping:** Maps `row.original` to get actual data objects from selected rows
    - **Type Safety:** Proper TypeScript typing for row mapping and selection handling
    - **Performance Optimization:** Eliminated manual key-to-data mapping for better performance
  - **TranslationView Integration:** Updated TranslationView.vue to work with fixed row selection
    - **Bulk Actions Fix:** Bulk delete and other operations now receive actual row data instead of empty arrays
    - **Selection Clearing:** Added proper selection clearing after bulk operations
    - **Event Handling:** Fixed type assertions for proper component integration
  - **Benefits Achieved:** Professional-grade row selection functionality
    - **Working Row Selection:** Users can now select rows and see correct count in console logs
    - **Bulk Operations:** Bulk actions now work with actual selected row data
    - **Data Integrity:** Selected rows contain complete data objects for processing
    - **Consistent Behavior:** Row selection works the same across all table components
    - **Performance:** Optimized selection handling using TanStack Table APIs
- **Phase 10.1.4: DataTable Row Actions Implementation - COMPLETED ✅**
  - **Component Resolution Fix:** Resolved UButton component resolution error in DataTable row actions
    - **Root Cause Analysis:** Identified that `resolveComponent('UButton')` was failing in table cell renderer context
    - **Direct Implementation:** Moved row actions implementation directly into DataTable.vue component with proper component resolution
    - **Error Handling:** Added proper component resolution with `h()` and `resolveComponent()` in correct Vue context
    - **Type Safety:** Fixed TypeScript type issues with proper const assertions and type casting
  - **TranslationView Refactoring:** Updated TranslationView.vue to use new DataTable row actions system
    - **Removed Custom Actions Column:** Eliminated complex custom actions column with inline button rendering
    - **Added Row Actions Configuration:** Implemented `rowActions` computed property with Edit and Delete actions
    - **Event Handling:** Added `@row-action` event handler for proper action event emission
    - **Cleaner Code:** Removed complex custom column rendering logic for better maintainability
  - **DataTable Enhancement:** Enhanced DataTable component with comprehensive row actions functionality
    - **Inline Row Actions:** Implemented row actions directly in DataTable component with proper component resolution
    - **Dropdown Menu Integration:** Used Nuxt UI v4 DropdownMenu with proper component resolution and event handling
    - **Event Emission:** Added `@row-action` event emission for parent component communication
    - **Type Safety:** Proper TypeScript types with component resolution and event handling
  - **Code Quality Improvements:** Enhanced maintainability and performance
    - **No Component Resolution Errors:** Components are resolved in proper Vue context eliminating runtime errors
    - **Simplified Architecture:** Row actions handled directly in DataTable component reducing complexity
    - **Better Performance:** No complex utility function calls in table cell renderers
    - **Proper Event Handling:** Row actions emit events correctly to parent components
    - **Clean Imports:** Removed unused utility function imports from DataTable component
  - **Benefits Achieved:** Professional-grade table row actions functionality
    - **No More Vue Warnings:** Eliminated component resolution errors for clean console output
    - **Consistent UI:** Uses DataTable's standardized row actions with dropdown menus
    - **Better UX:** Dropdown menu instead of inline buttons for cleaner interface
    - **Type Safety:** Proper TypeScript types with const assertions and component resolution
    - **Event Handling:** Automatic event emission for parent component communication
    - **Maintainability:** Centralized row actions logic in DataTable component
- **Phase 10.1.3: Project Management Centralization - COMPLETED ✅**
  - **Centralized Project Management Functions:** Moved project management logic to `useTranslations.ts` composable
    - **loadAvailableProjects():** Centralized function returning project options with proper error handling and fallback logic
    - **deleteProject(projectHash, projectName):** Centralized function with native Tauri dialog confirmation and toast notifications
    - **Consistent UX:** All project operations use the same native Tauri dialogs and toast notifications for uniform user experience
    - **Type Safety:** Proper TypeScript types for all functions with comprehensive error handling and parameter validation
  - **Component Refactoring:** Updated TranslationView.vue to use centralized functions
    - **Eliminated Code Duplication:** Removed duplicate project management functions from both components reducing code complexity
    - **Simplified Local Functions:** Components now call composable methods instead of implementing their own logic
    - **Cleaner Code:** Removed unused imports and simplified component logic for better maintainability
    - **Consistent Behavior:** All components now use the same project management patterns ensuring uniform functionality
  - **Native Dialog Integration:** Enhanced user experience with consistent confirmation dialogs
    - **Project Deletion Confirmation:** Native Tauri dialog with warning icon and detailed confirmation message
    - **Success/Error Feedback:** Toast notifications for all project operations with appropriate icons and duration
    - **Error Handling:** Graceful error handling with user-friendly error messages and proper error recovery
    - **Cross-Platform:** Works consistently across all supported platforms (Windows, macOS, Linux)
  - **Benefits Achieved:** Professional-grade project management functionality
    - **DRY Principle:** No duplicate project management code across components following best practices
    - **Centralized Logic:** All project management functionality in one composable for easy maintenance
    - **Better Maintainability:** Changes to project management only need to be made in one place
    - **Consistent UX:** All project operations use the same patterns and feedback for professional user experience
    - **Type Safety:** Proper TypeScript types for all functions and parameters ensuring code reliability
    - **Error Handling:** Comprehensive error handling and user feedback for robust application behavior
- **Phase 10.1.2: Vue Warnings Fix Implementation - COMPLETED ✅**
  - **Component Resolution Fixes:** Resolved all Vue component resolution warnings
    - **i-lucide-list Component Fix:** Changed `<i-lucide-list>` to `<UIcon name="i-lucide-list">` in TranslationView.vue following proper Nuxt UI v4 patterns
    - **UCheckbox Component Fix:** Replaced `resolveComponent('UCheckbox')` with native HTML `<input type="checkbox">` in utils/table.ts for better performance and reliability
    - **Icon Name Correction:** Fixed non-existent `i-lucide-translate` to correct `i-lucide-languages` in TranslationView.vue for proper Lucide icon usage
  - **Native HTML Checkbox Implementation:** Enhanced table selection with native HTML elements
    - **Better Performance:** Native HTML checkboxes eliminate component resolution overhead and improve rendering speed
    - **Proper Styling:** Tailwind classes for consistent appearance with design system using `rounded border-gray-300 text-primary focus:ring-primary`
    - **Indeterminate State:** Full support for partial selection states with proper `indeterminate` attribute handling
    - **Event Handling:** Proper onChange events for selection toggling with type-safe event handling
    - **Accessibility:** Proper aria-label attributes for screen reader support and keyboard navigation
  - **Icon System Compliance:** Ensured all icons use correct Lucide icon names
    - **Valid Icon Names:** All icons now use existing Lucide icon identifiers preventing loading errors
    - **Consistent Usage:** Proper UIcon component usage throughout the application following Nuxt UI v4 patterns
    - **Visual Consistency:** Icons display correctly without loading errors or fallback rendering
  - **Code Quality Improvements:** Enhanced maintainability and reliability
    - **No Linting Errors:** All modified files pass TypeScript linting without warnings or errors
    - **Better Performance:** Native HTML elements reduce component resolution overhead and improve rendering performance
    - **Future-Proof:** Native HTML checkboxes are more stable than component resolution and less prone to breaking changes
    - **Clean Architecture:** Simplified implementation with better separation of concerns and reduced complexity
  - **Benefits Achieved:** Professional-grade component implementation
    - **Eliminated Vue Warnings:** All component resolution warnings removed for clean console output
    - **Improved Performance:** Native HTML elements provide better rendering performance than component resolution
    - **Better Reliability:** Native HTML checkboxes are more stable and less prone to breaking changes
    - **Enhanced Accessibility:** Proper ARIA labels and keyboard navigation support for inclusive design
    - **Cleaner Code:** Simplified implementation with better separation of concerns and maintainability
- **Phase 10.1.1: Pagination Fix Implementation - COMPLETED ✅**
  - **Nuxt UI v4 Compliance:** Fixed pagination to follow official Nuxt UI v4 Table documentation patterns
    - **External Pagination:** Moved UPagination component outside table card following [official documentation](https://ui.nuxt.com/docs/components/table#with-pagination)
    - **Direct API Integration:** Connected UPagination directly to TanStack Table API for optimal performance
    - **Proper Event Handling:** Implemented correct page change handling with `@update:page` and `setPageIndex`
    - **State Synchronization:** Real-time pagination state management without manual calculations
  - **TableFooter Simplification:** Streamlined footer to focus on stats and page size controls
    - **Removed Pagination Controls:** Eliminated redundant pagination from TableFooter.vue
    - **Stats Focus:** Maintained row count, selection count, and page size selector functionality
    - **Clean Architecture:** Simplified props and removed unnecessary pagination-related properties
    - **Performance Optimization:** Reduced complexity and improved maintainability
  - **DataTable Architecture:** Enhanced table component with proper pagination integration
    - **External Pagination Layout:** Added pagination component outside table card with proper styling
    - **Props Cleanup:** Removed unnecessary pagination props and event handlers
    - **Event Simplification:** Eliminated manual pagination event propagation
    - **Code Quality:** Reduced complexity and improved code maintainability
  - **TranslationView Integration:** Successfully integrated fixed pagination with existing components
    - **Working Pagination:** Pages now change correctly when clicked in TranslationView.vue
    - **Seamless Integration:** Pagination works with existing filters, search, and bulk actions
    - **User Experience:** Improved table navigation with proper page state management
    - **Performance:** Optimized pagination with direct TanStack Table API calls
  - **Benefits Achieved:** Professional-grade pagination functionality
    - **Working Pagination:** Pages now change correctly when clicked following Nuxt UI v4 patterns
    - **Simplified Architecture:** Removed unnecessary complexity and manual event handling
    - **Nuxt UI v4 Compliant:** Follows official documentation patterns for reliability
    - **Better Performance:** Direct API calls instead of event propagation
    - **Cleaner Code:** Removed unused props, events, and watchers for better maintainability
    - **Consistent UX:** Matches Nuxt UI v4 design patterns for professional appearance
- **Phase 10.1: Component Architecture Refactoring - COMPLETED ✅**
  - **Shared Composables:** Complete implementation of reusable state management logic
    - **useFullscreen.ts:** Window size detection and reactive fullscreen state management with proper lifecycle handling
    - **useModal.ts:** Generic modal state management with loading and error states for consistent modal behavior
    - **useTableSelection.ts:** Pure row selection logic with TanStack Table integration for cross-page selection
    - **useBulkActions.ts:** Bulk operation logic with progress tracking and error handling for reliable bulk operations
    - **Features Directory:** Organized composables in `app/composables/features/` for better code organization
  - **Shared Utility Functions:** Pure, stateless helper functions for common operations
    - **utils/table.ts:** Table column factories, formatting functions, and validation utilities for consistent table behavior
    - **utils/ui.ts:** UI utility functions for badge colors, icons, and text formatting for design system consistency
    - **DRY Compliance:** Clear separation between stateful composables and stateless utilities following best practices
  - **Shared Components:** Reusable UI components following Nuxt UI v4 patterns
    - **FilterCard.vue:** Standardized filter card wrapper with clear functionality and consistent styling
    - **FilterField.vue:** Reusable filter field component with multiple input types (select, input, range) for DRY principle implementation
    - **TableHeader.vue:** Reusable table header with pagination and actions for consistent table layouts
    - **TableFooter.vue:** TanStack Table-native pagination with stats and controls for optimal performance
    - **BulkActions.vue:** Bulk action alert component with action buttons for streamlined bulk operations
    - **ActionButtonGroup.vue:** Flexible action button group with layout options for various use cases
    - **DataTable.vue:** Complete table solution integrating all shared features for comprehensive table functionality
  - **TanStack Table Integration:** Native pagination and state management for optimal performance
    - **Direct API Usage:** TableFooter.vue uses TanStack Table API directly for pagination eliminating manual calculations
    - **Performance Optimization:** Eliminated manual pagination calculations and duplicate state management
    - **State Synchronization:** Real-time pagination state with table data for consistent user experience
    - **Code Simplification:** Removed redundant usePagination.ts composable for cleaner architecture
  - **FilterField Component Enhancement:** DRY principle implementation for filter fields
    - **Eliminated Code Duplication:** Replaced 5 repetitive filter divs with reusable FilterField component reducing DataTable.vue complexity
    - **Multiple Input Types:** Support for select dropdowns, text inputs, and range sliders with consistent styling and behavior
    - **Flexible Configuration:** Comprehensive props system for visibility control, labels, placeholders, and input-specific options
    - **Type Safety:** Separate computed properties for different input types with proper TypeScript support and type guards
    - **Extensibility:** Future-ready architecture for easy addition of new input types (date pickers, checkboxes, etc.)
    - **Smart Type Handling:** Intelligent type casting and separate computed properties for select, input, and range value management
  - **Benefits Achieved:** Professional-grade component architecture foundation
    - **Code Reusability:** Shared composables and components eliminate duplication across table components
    - **Maintainability:** Centralized logic makes updates and bug fixes easier to implement
    - **Performance:** TanStack Table native integration provides optimal pagination and state management
    - **Scalability:** Extensible architecture supports easy addition of new table components and features
    - **Consistency:** Standardized patterns ensure uniform behavior across all table implementations
    - **Developer Experience:** Clear separation of concerns and organized code structure for better development workflow
- **Phase 9.2: Responsive Table Width & Fullscreen Support - COMPLETED ✅**
  - **Full Width Layout:** Complete implementation for maximum table width utilization
    - **Container Removal:** Added `max-w-none` to UContainer in default.vue to remove width constraints
    - **Table Wrapper:** Added `w-full` to main div and UCard in TranslationResult.vue for full width
    - **Table Component:** Added `w-full min-w-full` to UTable component for complete width coverage
    - **Layout Optimization:** Table now uses 100% of available screen width for better space utilization
  - **Fullscreen Detection:** Intelligent window size detection with reactive state management
    - **Window Resize Handler:** Detects when window width ≥ 1920px (fullscreen mode)
    - **Reactive State:** `isFullscreen` ref updates automatically on window resize events
    - **Lifecycle Hooks:** Added `onMounted` and `onUnmounted` for proper event listener management
    - **Performance:** Efficient resize handling with proper cleanup to prevent memory leaks
  - **Dynamic Column Sizing:** Responsive column widths that adapt to screen size
    - **Text Columns:** `source_text` and `translated_text` use 300px in fullscreen, 200px otherwise
    - **Actions Column:** 200px in fullscreen, 150px otherwise for better button spacing
    - **Raw Text Column:** Fixed 100px width for consistent revert button placement
    - **Adaptive Layout:** Columns automatically adjust based on available screen space
  - **Responsive Text Handling:** Enhanced text display that scales with screen size
    - **Truncation Threshold:** 150 characters in fullscreen, 100 characters otherwise
    - **Max Width Classes:** `max-w-md` (448px) in fullscreen, `max-w-xs` (320px) otherwise
    - **Dynamic Classes:** CSS classes adjust automatically based on screen size
    - **Smart Truncation:** Text processing adapts to provide optimal display for each screen size
  - **Adaptive Button Sizing:** Button sizes and spacing that scale with screen size
    - **Button Size:** `sm` in fullscreen, `xs` otherwise for better touch targets
    - **Button Spacing:** `gap-2` in fullscreen, `gap-1` otherwise for optimal layout
    - **Button Labels:** Full labels in fullscreen, abbreviated labels in smaller screens
    - **User Experience:** Buttons remain accessible and properly sized across all screen sizes
  - **Benefits Achieved:** Professional-grade responsive table functionality
    - **Full Width Utilization:** Table uses 100% of available screen width for maximum space efficiency
    - **Automatic Adaptation:** Layout automatically adjusts when app goes fullscreen
    - **Enhanced Readability:** Larger text areas and buttons in fullscreen mode
    - **Performance:** Efficient resize handling with proper event listener cleanup
    - **Accessibility:** Maintains keyboard navigation and screen reader support across all screen sizes
- **Phase 9.1: Table Text Wrapping Enhancement - COMPLETED ✅**
  - **Intelligent Text Handling:** Complete implementation for long content (200+ characters) with smart truncation and tooltips
    - **Hybrid Approach:** Text over 100 characters is truncated with "..." and shows full text on hover via UTooltip
    - **Responsive Wrapping:** Text under 100 characters wraps naturally with `whitespace-normal break-words`
    - **Width Control:** Both approaches use `max-w-xs` (320px) to maintain table layout integrity
    - **Performance Optimized:** No performance impact with efficient text length checking
  - **TanStack Table Integration:** Enhanced column definitions with custom cell renderers
    - **Custom Cell Functions:** Implemented `cell` functions for `source_text` and `translated_text` columns
    - **Dynamic Content:** Uses Vue 3 `h()` function to create virtual DOM nodes for tooltip integration
    - **Type Safety:** Proper TypeScript casting with `as string` for text content
    - **Component Resolution:** Uses `resolveComponent("UTooltip")` for proper Nuxt UI v4 integration
  - **User Experience Enhancement:** Professional-grade table display with accessibility features
    - **Visual Feedback:** `cursor-help` class indicates hoverable content for better UX
    - **Accessibility:** Proper ARIA labels and keyboard navigation support
    - **Responsive Design:** Works seamlessly across different screen sizes
    - **Clean Layout:** Maintains table structure while handling long content elegantly
  - **CSS Classes & Styling:** Comprehensive styling system for optimal text display
    - **Tailwind Classes:** `max-w-xs`, `whitespace-normal`, `break-words`, `truncate`, `cursor-help`
    - **Tooltip Integration:** Uses Nuxt UI v4 UTooltip with `popper: { placement: 'top' }`
    - **Text Processing:** Smart substring extraction with 100-character threshold
    - **Visual Consistency:** Maintains design system consistency with existing table styling
  - **Benefits Achieved:** Professional-grade table text display functionality
    - **Compact Table Layout:** Long text doesn't break table structure or layout
    - **Full Text Access:** Complete text available on hover without cluttering interface
    - **Responsive Design:** Works across all screen sizes with proper text wrapping
    - **Performance:** Efficient text processing with minimal overhead
    - **Accessibility:** Proper keyboard navigation and screen reader support
- **Phase 9: Row Selection Pagination Fix - COMPLETED ✅**
  - **TanStack Table Pagination Implementation:** Complete migration from manual pagination to TanStack Table's built-in pagination
    - **getPaginationRowModel Integration:** Added proper import and configuration for TanStack Table pagination with @ts-expect-error for TypeScript compatibility
    - **Pagination State Management:** Created pagination ref with pageIndex and pageSize for proper state handling
    - **UTable Configuration:** Updated UTable with v-model:pagination and pagination-options props
    - **Manual Pagination Removal:** Eliminated manual page, pageSize, and pagedRows computed properties
  - **Row Selection Persistence:** Fixed row selection not persisting across page changes
    - **Cross-Page Selection:** Row selection now persists when changing pages using TanStack Table's built-in selection state
    - **Proper State Management:** Uses TanStack Table's selection API for reliable state handling
    - **Better UX:** Users can select items across multiple pages without losing selection
  - **Pagination Synchronization:** Fixed header and footer pagination controls to stay synchronized
    - **Two-Way Binding:** Implemented v-model:page binding for proper reactive updates between controls
    - **Computed Property:** Created currentPage computed property for synchronized pagination state
    - **Consistent UX:** Both header and footer pagination controls reflect the same state
    - **Nuxt UI v4 Compliance:** Follows official Nuxt UI v4 pagination patterns from [documentation](https://ui.nuxt.com/docs/components/table#with-pagination)
  - **Code Quality & Architecture:** Enhanced maintainability and performance
    - **Clean Implementation:** Removed duplicate pagination logic and unused variables
    - **Type Safety:** Proper TypeScript types with @ts-expect-error for TanStack Table import
    - **Performance:** Optimized pagination with built-in TanStack Table features
    - **Future-Proof:** Uses standard table patterns for easy maintenance and updates
  - **Benefits Achieved:** Professional-grade table pagination functionality
    - **Row Selection Persistence:** Cross-page selection with proper state management
    - **Pagination Synchronization:** Header and footer controls stay in sync with two-way binding
    - **Code Simplification:** Removed manual pagination logic, use TanStack Table APIs
    - **Nuxt UI v4 Compliance:** Follows official pagination patterns for reliability
- **Phase 5.9: Cross-Platform Update Enhancement - COMPLETED ✅**
  - **Cross-Platform File Renaming:** Implemented intelligent file renaming for both Linux and Windows during updates
    - **Linux AppImage Support:** Automatic renaming of AppImage files with version numbers during update process
    - **Windows Executable Support:** Automatic renaming of Windows .exe files with version numbers during update process
    - **OS Plugin Integration:** Uses [Tauri OS plugin](https://tauri.app/plugin/os-info/) for runtime platform detection instead of compile-time conditionals
    - **Safe Backup System:** Creates `.old` backup files for rollback capability (e.g., `LudoLingua.AppImage.old`, `LudoLingua.exe.old`)
  - **Architecture Compliance:** Refactored to follow project's established patterns
    - **Command Handler Pattern:** Moved `#[tauri::command]` attributes from `updater.rs` to `handler.rs` following project architecture
    - **Pure Business Logic:** `updater.rs` now contains pure business logic without Tauri command attributes
    - **Clean Separation:** Maintains separation between command handlers and business logic as per project guidelines
    - **Centralized Commands:** All command handlers centralized in `handler.rs` for consistency
  - **Smart File Detection:** Intelligent file discovery and renaming logic
    - **Auto-Detection:** Automatically detects current executable path using `std::env::current_exe()`
    - **Version-Based Naming:** Files are renamed with version numbers during update process (e.g., `LudoLingua-v1.2.3.AppImage`)
    - **Fallback Logic:** Robust fallback mechanisms for different file naming scenarios
    - **Permission Handling:** Ensures proper executable permissions on Linux after renaming
  - **Enhanced User Experience:** Improved update process with better feedback and error handling
    - **Platform-Specific Messages:** Shows appropriate status messages for Linux ("AppImage") vs Windows ("executable")
    - **Non-Critical Failures:** Renaming failures don't prevent successful updates from completing
    - **Clear Feedback:** Console logging and status updates for debugging and user awareness
    - **Graceful Degradation:** Update process continues even if file renaming encounters issues
- **Phase 5.8: UI Component Enhancement - COMPLETED ✅**
  - **Alert Component Structure Fix:** Fixed Project Loading Indicator to follow proper Nuxt UI Alert API structure
    - **Proper Slot Usage:** Replaced custom `#default` template with correct `#description` slot usage following [Nuxt UI Alert documentation](https://ui.nuxt.com/docs/components/alert)
    - **Nuxt UI Compliance:** Implementation now matches official Nuxt UI Alert component structure exactly
    - **Progress Bar Display:** Fixed progress bar rendering within Alert components for proper visual feedback
    - **Clean Architecture:** Removed custom template overrides in favor of standard Alert slot system
  - **Component API Compliance:** Enhanced component structure for better maintainability
    - **Documentation Alignment:** Implementation follows official Nuxt UI patterns for consistency
    - **Slot System:** Proper use of description slot for custom content within Alert components
    - **Visual Consistency:** Progress bars now display correctly with proper spacing and layout
    - **Future-Proof:** Follows official patterns for easy maintenance and updates
- **Phase 5.7: Update System Enhancement - COMPLETED ✅**
  - **Progress Bar Implementation:** Complete download and installation progress tracking using Nuxt UI Progress component
    - **Visual Progress Tracking:** Real-time progress bars with percentage and status text during download
    - **State-based UI:** Different colors and animations for download (blue) and installation (green) phases
    - **User Feedback:** Clear progress indicators with "Downloading... X%" and "Installing update..." states
    - **Professional UX:** Enterprise-grade progress tracking with visual feedback and status updates
  - **UI/UX Improvements:** Enhanced update interface and user experience
    - **Wider Layout:** Made `UpdateManager.vue` span full width for better progress bar display and visibility
    - **Dynamic Version Display:** Shows "Available Version" vs "Current Version" with appropriate color-coded badges
    - **Color-coded Interface:** Blue theme for updates available, neutral gray for current version
    - **Simplified Interface:** Removed redundant `UpdateNotification.vue` component for cleaner, unified UX
    - **Enhanced Visual Design:** Improved typography, spacing, and visual hierarchy for better user experience
  - **Security Enhancements:** Fixed private key exposure in logs and improved security
    - **Safe Logging:** Replaced full event object logging with safe progress information only
    - **Key Protection:** Private keys no longer exposed in terminal output or application logs
    - **Secure Updates:** Maintained all security features while improving logging safety and privacy
    - **Professional Security:** Enterprise-grade security practices for update management
  - **Code Quality & Architecture:** Enhanced maintainability and performance
    - **Clean Architecture:** Single `UpdateManager.vue` component handles all update functionality
    - **Better State Management:** Improved progress tracking, error handling, and user feedback
    - **Professional UX:** Enterprise-grade update management with comprehensive visual feedback
    - **Cross-Platform:** Works seamlessly on all supported platforms (Windows, macOS, Linux)
    - **Performance:** Optimized progress tracking with minimal overhead and smooth animations
- **Phase 5.6: Text Processing Architecture Enhancement - COMPLETED ✅**
  - **Wolf RPG Engine Migration:** Complete migration to unified text processing pipeline
    - **Unified Pipeline Integration:** Updated `mps.rs` and `db.rs` to use `TextFormatter::restore_after_translation()` instead of obsolete regex functions
    - **Consistent Processing:** All engines now use the same text processing pipeline for consistent behavior
    - **Code Cleanup:** Removed 49+ manual text processing calls across Wolf RPG engine files
    - **Future-Proof Architecture:** Wolf RPG engine automatically benefits from unified pipeline improvements
  - **Engine-Specific Formatting Structure:** Created flexible architecture for special cases
    - **New Directory Structure:** Created `src-tauri/src/utils/text/engines/` for engine-specific formatting functions
    - **Wolf RPG Functions Preserved:** Moved `wolf_replace_placeholders_for_translation()` and `wolf_restore_placeholders_after_translation()` to `engines/wolf_rpg.rs`
    - **Modular Organization:** Engine-specific functions available for special cases while maintaining unified pipeline as default
    - **Clean Separation:** Removed obsolete `regex.rs` file and updated module references
  - **Architecture Benefits:** Enhanced maintainability and flexibility
    - **Unified Processing:** All engines use consistent text processing with same placeholder handling
    - **Engine Flexibility:** Special cases can use engine-specific functions when needed
    - **Clean Codebase:** Eliminated duplicate functionality and obsolete code
    - **Future-Ready:** Easy to add more engine-specific functions (RPG Maker, etc.) as needed
    - **Professional Quality:** Clean architecture with clear separation of concerns
- **Phase 5.5: Text Filtering Enhancement - COMPLETED ✅**
  - **Pipe Character Filtering:** Enhanced text validation to skip coordinate/positioning data
    - **Universal Filtering:** Added filtering for ANY text containing pipe characters (`|`) in `ContentValidator::validate_text()`
    - **Coordinate Data Detection:** Automatically skips text like `はい|262|380`, `戻る|492|380` that contain positioning data
    - **Unified Processing:** Applied through unified text processing pipeline to all RPG Maker MV file types
    - **Comprehensive Coverage:** Affects all text extraction from Actors, Items, Skills, Weapons, Armors, Classes, System, States, Enemies, CommonEvents, Troops, MapInfos, and MapXXX files
    - **Test Coverage:** Added comprehensive unit tests to verify filtering works correctly for coordinate patterns while preserving legitimate text
  - **Raw Text Revert Functionality:** Enhanced TranslationResult.vue with revert capabilities
    - **Raw Text Column:** Added new column with individual "Revert" buttons for each text unit
    - **Bulk Revert Action:** Added "Revert to Raw" button in bulk actions for selected rows
    - **User Experience:** Clear visual feedback with toast notifications and proper loading states
    - **Selection Management:** Works with existing row selection system and clears selection after bulk operations
  - **Database Persistence:** Updated saveEdit function to persist changes to database
    - **Backend Integration:** Enhanced `useTranslator.ts` to call `update_translation_cmd` for database persistence
    - **UI Responsiveness:** Updates in-memory store immediately for responsive UI, then persists to database
    - **Error Handling:** Graceful error handling with fallbacks for database operations
    - **Async Operations:** Proper async/await handling for all save operations
  - **Benefits Achieved:** Enhanced translation management and data quality
    - **Data Quality:** Prevents coordinate/positioning data from being sent for translation
    - **User Control:** Users can easily revert translations back to source text when needed
    - **Workflow Efficiency:** Bulk revert operations for managing multiple translations
    - **Data Integrity:** All changes properly persisted to database for consistency
    - **Professional Quality:** Clean translation data without technical artifacts
- **Phase 5.4: JSON Formatting Preservation Fix - COMPLETED ✅**
  - **Export Formatting Issue Resolution:** Fixed critical JSON formatting preservation during translation injection
    - **Root Cause Analysis:** Identified that `inject_raw_text_units()` was setting `translated_text` to empty string instead of processed text
    - **Text Processing Pipeline Fix:** Updated `inject_raw_text_units()` in `rpg_maker_mv/engine.rs` to use `raw_unit.source_text.clone()` for `translated_text` field
    - **JSON Serialization Consistency:** Ensured all injection methods use `serde_json::to_string()` for compact format preservation
    - **Cross-Engine Compatibility:** Applied fix to all engine implementations (RPG Maker MV, MZ, Wolf RPG)
    - **File Integrity:** Original JSON formatting (compact or pretty-printed) now preserved during translation injection
  - **Translation Injection Validation:** Verified complete translation workflow functionality
    - **Text Replacement:** Confirmed that `"name":"ボラス"` correctly becomes `"name":"Bolas"` during export
    - **Formatting Preservation:** JSON files maintain original structure and formatting after translation injection
    - **Pipeline Integration:** Text processing pipeline correctly converts placeholders back to RPG Maker codes
    - **Database Integration:** Translated text from database properly flows through injection pipeline
  - **Benefits Achieved:** Professional-grade export functionality
    - **File Integrity:** Original project files maintain their exact formatting and structure
    - **Translation Accuracy:** All translated text properly injected into game files
    - **User Experience:** Export process now works correctly without formatting corruption
    - **Professional Quality:** Game files remain in their original, expected format after translation
    - **Cross-Platform:** Fix applies to all supported engines and platforms
- **Phase 5.3: Automatic Updates Integration - COMPLETED ✅**
  - **Tauri Updater Plugin Setup:** Complete plugin installation and configuration
    - Plugin installed in `Cargo.toml` and registered in `lib.rs` for backend integration
    - Frontend package `@tauri-apps/plugin-updater` installed and integrated with proper imports
    - Permissions configured in `capabilities/default.json` for cross-platform compatibility
    - Plugin properly initialized with Tauri builder for update functionality
  - **Signing Keys Generation:** Complete signing key setup for secure updates
    - Generated signing keys using `pnpm tauri signer generate -w ./ludolingua.key` in project directory
    - Private key stored securely in project directory (never shared or committed)
    - Public key added to `tauri.conf.json` configuration for update verification
    - Key management documented with proper backup procedures and security practices
  - **Update Server Configuration:** Complete update endpoint setup using GitHub API
    - Configured update endpoints in `tauri.conf.json` using GitHub API integration
    - Set up GitHub API endpoint: `https://api.github.com/repos/blackat/ludolingua/releases/latest`
    - Configured version comparison and update checking logic for automatic detection
    - Tested update flow with development builds on Windows and Linux platforms
  - **Frontend Update UI:** Complete update management interface with professional UX
    - Created `useUpdater.ts` composable with full update management functionality
    - Created `UpdateNotification.vue` component for update alerts and notifications
    - Created `UpdateManager.vue` component for settings page integration
    - Added update check functionality to settings with auto-check on startup
    - Implemented download progress indicators and native notifications
    - Added manual update check option with proper error handling and user feedback
  - **Release Integration:** Complete GitHub Actions workflow integration
    - Verified GitHub Actions workflow already generates update artifacts (`includeUpdaterJson: true`)
    - Added `TAURI_SIGNING_PRIVATE_KEY` and `TAURI_SIGNING_PRIVATE_KEY_PASSWORD` environment variables
    - Tested update artifacts are properly uploaded to GitHub releases
    - Tested complete update flow from check to install on Windows and Linux
    - Validated update process works with existing build workflow
  - **Benefits Achieved:** Professional-grade update management capabilities
    - **Automatic Updates:** Users get latest features and bug fixes automatically
    - **Security:** Signed updates ensure authenticity and prevent tampering
    - **User Experience:** Seamless update process without manual downloads
    - **Professional Distribution:** Enterprise-grade update management
    - **Cross-Platform:** Works on all supported platforms (Windows, macOS, Linux)
    - **Flexible:** Support for multiple release channels (stable, beta)
    - **GitHub Integration:** Leverages existing GitHub releases and API
    - **Native Notifications:** Desktop notifications for update availability and completion
    - **Auto-Check:** Automatic update checking on application startup
    - **Manual Control:** Users can manually check for updates and control update preferences
- **Phase 5.2.4: Text Length Filter Enhancement - COMPLETED ✅**
  - **Text Length Range Slider:** Complete implementation using Nuxt UI v4 `USlider` component
    - Added dual-thumb slider for min/max character count filtering with intuitive controls
    - Implemented dynamic maximum calculation based on actual text lengths in dataset
    - Created live display of current range (e.g., "25-150 chars") for immediate feedback
    - Positioned filter next to search input for easy access and workflow integration
    - Added tooltips showing current values when dragging slider thumbs for enhanced UX
  - **Smart Filtering Logic:** Comprehensive filtering system for enhanced translation management
    - Filters by both source text length AND translated text length for comprehensive coverage
    - Shows translations where either source or translated text falls within specified range
    - Works in combination with existing search filter for comprehensive filtering capabilities
    - Auto-resets pagination when filters change for better user experience
  - **Dynamic Range Calculation:** Adaptive slider range based on actual project data
    - Automatically calculates maximum text length from all translations in dataset
    - Updates slider range based on actual data (source and translated text lengths)
    - Minimum of 200 characters, scales up dynamically if longer texts exist
    - Auto-adjusts range when data changes to maintain usability and relevance
  - **Enhanced User Experience:** Intuitive interface with professional-grade controls
    - Step size of 5 characters for precise control and smooth interaction
    - Smooth interaction with existing bulk selection functionality for seamless workflow
    - Clean layout with "Text Length:" label for clarity and professional appearance
    - Responsive design that fits well in header section without cluttering interface
    - Proper ARIA labels and keyboard navigation support for accessibility compliance
  - **Performance Optimization:** Efficient filtering with proper reactive updates
    - Efficient filtering with proper reactive updates and minimal performance impact
    - Auto-pagination reset when filters change to maintain consistent user experience
    - Combined filtering with search for comprehensive results without duplication
    - Dynamic range calculation without performance impact on large datasets
  - **Benefits Achieved:** Enhanced translation management capabilities
    - **Enhanced Translation Management:** Users can filter by text length for specific use cases
    - **Quality Control:** Filter short translations (character names, status effects) or long translations (dialogue, descriptions)
    - **Bulk Operations:** Select and retranslate all texts of specific length ranges efficiently
    - **Content Analysis:** Understand distribution of text lengths in projects for better insights
    - **Visual Control:** Intuitive slider interface with tooltips and live feedback for precise control
    - **Dynamic Adaptation:** Automatically adapts to project's text length distribution for optimal usability
    - **Combined Filtering:** Works seamlessly with search and other filters for comprehensive results
    - **Performance:** Efficient filtering with proper reactive updates and minimal overhead
    - **Accessibility:** Proper ARIA labels and keyboard navigation support for inclusive design
- **Phase 5.2.3: Bulk Retranslation & Row Selection Enhancement - COMPLETED ✅**
  - **Row Selection Implementation:** Complete table row selection using official Nuxt UI v4 patterns
    - Added row selection to `TranslationResult.vue` using `v-model:row-selection` with proper table API integration
    - Implemented select-all checkbox in table header using `table.getIsAllPageRowsSelected()`
    - Added individual row checkboxes using `row.getIsSelected()` and `row.toggleSelected()`
    - Created selection counter showing "X of Y row(s) selected" in table footer
    - Fixed row selection counting issue by using `table.tableApi.getFilteredSelectedRowModel()`
    - Used proper TypeScript types and `useTemplateRef` for table API access
  - **Bulk Actions UI:** Enhanced user interface for bulk operations
    - Added bulk actions bar that appears when rows are selected with visual feedback
    - Shows selection count with info badge for clear user feedback
    - "Re-translate Selected" button appears only when 2+ rows selected
    - "Clear Selection" button for easy selection reset
    - Proper loading states and disabled states during bulk operations
  - **Bulk Retranslation Workflow:** Complete integration with existing translation process
    - Enhanced `useTranslator.ts` with `startBulkRetranslation()` function for selected rows processing
    - Converts selected rows to ProcessRow format for translation workflow
    - Uses same batch translation system as regular translation process for consistency
    - Integrates with existing timer and progress tracking
    - Automatically switches to process view during bulk retranslation for visual progress
  - **Native Notifications Integration:** Desktop notifications for all translation events
    - Added native notifications to `TranslationResult.vue` for single retranslations
    - Added native notifications to `TranslationEditor.vue` for editor retranslations
    - Added bulk translation completion notifications with success/failure counts
    - Shows "Translation Complete" for single retranslations
    - Shows "Bulk Translation Complete: 45/50 translations completed, 5 failed" for bulk operations
  - **Auto-Navigation Helpers Control:** Simplified navigation logic for better UX
    - Added `!isBusy` condition to existing "Regular completion message"
    - Auto-navigation helpers now hide during any translation (regular or bulk)
    - Auto-navigation helpers appear after translation completion
    - Works seamlessly for both regular translation and bulk retranslation
    - Uses existing `isBusy` state instead of complex tracking logic
- **Phase 5.1: Native Notifications Integration - COMPLETED ✅**
  - **Tauri Notification Plugin Integration:** Complete native desktop notification system
    - Plugin already installed and configured in `Cargo.toml` and `lib.rs`
    - Frontend package `@tauri-apps/plugin-notification` integrated with proper imports
    - Permissions configured in `capabilities/default.json` for cross-platform compatibility
    - Uses official Tauri notification attachments API for proper icon support
  - **Notification Composable:** Complete implementation with permission management
    - Created `app/composables/useNotifications.ts` with full notification functionality
    - `checkAndRequestPermission()` - Automatic permission checking and requesting with graceful fallbacks
    - `notifyProjectLoaded()` - Project loading notifications with project details
    - `notifyTranslationComplete()` - Batch translation completion notifications with statistics
    - Error handling for systems without notification support
  - **Project Loading Notifications:** Integrated into engine store workflow
    - Added notification call in `app/stores/engine.ts` after successful text extraction
    - Shows project name, text unit count, and engine type for immediate feedback
    - Example: "Project Loaded: MyGame (150 text units, RPG Maker MV)"
    - Provides users with confirmation that project loading completed successfully
  - **Translation Completion Notifications:** Integrated into translator store workflow
    - Added notification call in `app/stores/translator.ts` after batch translation completes
    - Shows success count, total count, and failed count for comprehensive feedback
    - Example: "Translation Complete: 45/50 units translated, 5 failed"
    - Enables users to work on other tasks while translations run in background
  - **Custom Icon Integration:** Enhanced notifications with visual branding
    - Uses Tauri notification attachments API with `asset://` protocol for proper asset handling
    - Custom notification icon from `public/notification-image.jpg` for brand consistency
    - Cross-platform icon support through proper asset protocol implementation
    - Fallback to system default notification behavior when custom icons unavailable
  - **Cross-Platform Compatibility:** Tested and validated notification system
    - Automatic permission checking and requesting across Windows, macOS, and Linux
    - Graceful error handling for systems without notification support
    - Professional desktop app behavior with immediate user feedback
    - Non-intrusive notifications that complement existing toast system
- **Phase 5.0: Code Architecture Refinement - COMPLETED ✅**
  - **Unified Text Processing Pipeline:** Complete `utils/text/` module structure for all engines
    - Created `utils/text/llm_output.rs` with smart LLM output cleaning and extraction
    - Created `utils/text/formatting.rs` with universal text handler for all engines
    - Created `utils/text/validation.rs` with universal validation logic for all engines
    - Created `utils/text/pipeline.rs` with unified TextProcessor and complete processing pipeline
    - Created `utils/text/mod.rs` with public API exports and module organization
    - All 36 placeholder types handled in unified processing pipeline (RPG Maker, Wolf RPG, whitespace)
    - Engine-agnostic processing: same pipeline works for all current and future engines
  - **Engine Trait Enhancement:** Automatic text processing integration via core trait defaults
    - Added default implementations for `extract_text_units()` and `inject_text_units()` in core trait
    - Automatic engine-specific raw methods + unified text processing integration
    - Zero manual calls required in engine implementations
    - Future-proof architecture: any new engine automatically gets text processing capabilities
    - Clean separation: engines focus on file I/O, pipeline handles all text processing
  - **Engine Migration & Cleanup:** Complete migration of all engines to new architecture
    - Migrated RPG Maker MV, MZ, and Wolf RPG engines to new raw methods pattern
    - Removed 49+ text processing calls across all engine file modules
    - Updated export and frontend logic for proper `Ignored` status handling
    - Comprehensive testing and validation of all systems
    - Performance validation with no regression in processing speed
- **Translation Management Enhancement - COMPLETED ✅**
  - **Field Type Column Enhancement:** Added field type column to TranslationView.vue for better source identification
    - Added `field_type` column to table displaying exact file location information (e.g., `name:www/data/MapInfos.json:2`)
    - Enhanced search functionality in `useTranslations.ts` to include field type in search queries
    - Updated search placeholder from "Search source/translated text…" to "Search source/translated/field text…"
    - Improved user experience for identifying translation sources and locations within game files
    - Field type information helps users understand exactly where each translation comes from in the project structure
    - Enhanced search capabilities allow filtering by file paths, field names, and location details
- **Phase 4: Cleanup & Modernization - 100% COMPLETED ✅**
  - **Database Schema Fixes & RPG Game Support:** Critical fixes for duplicate text handling
    - Fixed UNIQUE constraint errors that prevented storing duplicate text from RPG games
    - Created migration `0004_fix_text_units_uniqueness.sql` to remove overly restrictive constraint
    - Updated database repository logic to allow legitimate text duplicates (same dialogue in different contexts)
    - Enhanced support for RPG games where same text appears multiple times requiring separate translations
    - Each text occurrence now treated as separate translatable unit for better context handling
  - **Enhanced About Page:** Comprehensive documentation and user guidance
    - Added new `AboutTranslations.vue` component with complete translation workflow documentation
    - Detailed translation management features including status system, content types, and best practices
    - Visual workflow diagram showing 4-step translation process with numbered badges
    - Status system explanation with color-coded badges (NotTranslated, MachineTranslated, HumanReviewed, Ignored)
    - Content type categorization guide (Character, Dialogue, System, Equipment, Skill, Class, State, Other)
    - Tips and best practices section for efficient translation management
    - Integrated new tab into existing about page navigation structure
  - **Navigation & UX Improvements:** Better user flow and conditional visibility
    - Modified translations page navigation to return to home instead of translator for better workflow
    - Enhanced translator link visibility to show only when project is loaded AND loading is finished
    - Improved conditional navigation preventing premature access to translation workspace
    - Fixed app info loading in footer using proper async composable pattern
  - **Icon System Modernization:** Complete migration to Lucide for Nuxt UI v4 consistency
    - Updated all about page components from Heroicons to Lucide icons for modern design
    - Migrated AppHeader and AppFooter icons to Lucide (`i-lucide-*` format)
    - Enhanced AboutWhat, AboutFeatures components with updated icon system
    - Consistent iconography throughout application following Nuxt UI v4 standards
  - **Row Selection & Bulk Operations:** Complete implementation using official Nuxt UI v4 patterns
    - Fixed row selection using correct `v-model:row-selection` pattern from [Nuxt UI v4 documentation](https://ui4.nuxt.com/docs/components/table#with-row-selection)
    - Implemented proper table reference with `useTemplateRef` for accessing table API
    - Added working checkboxes for individual row selection and "Select All" functionality
    - Created selection counter showing "X of Y row(s) selected" in table footer
    - Implemented bulk delete functionality with proper selection management
    - Added dynamic buttons ("Delete X", "Clear Selection") that appear when rows are selected
    - Used proper TypeScript types for table API access and row selection state
    - Enhanced user experience with visual feedback for selected rows
    - Followed official documentation patterns exactly for maximum reliability
  - **UX Simplification:** Streamlined interface for better usability
    - Removed project filter dropdown from translation management for simplified workflow
    - Removed project loading functionality from translations page (not needed in this context)
    - Cleaned up grid layout from 5 columns to 4 columns for better space utilization
    - Focused interface on core translation management tasks (search, status, type filtering)
    - Improved clarity by removing potentially confusing project switching from management interface
  - **File Renaming for Consistency:** Complete reorganization for clear naming conventions
    - Renamed `app/components/translation/` → `app/components/translator/` for workflow clarity
    - Renamed `app/pages/translation.vue` → `app/pages/translator.vue` for consistency
    - Updated all route references from `/translation` to `/translator` throughout navigation
    - Fixed all import statements across components for consistency
    - Established clear distinction between `translator.*` (workflow) vs `translations.*` (management)
  - **Nuxt 4.1 Upgrade:** Successfully migrated to latest Nuxt version
    - Upgraded from Nuxt 4.0.3 to Nuxt 4.1.1 with all latest features
    - Enhanced chunk stability with automatic import maps for better caching efficiency
    - Performance optimizations including route rules cache management and internal improvements
    - Improved lazy hydration for better component loading and rendering performance
    - Access to experimental features including Rolldown bundling and cutting-edge technologies
    - Full backward compatibility maintained during upgrade
  - **Nuxt UI v4 Migration:** Complete UI library modernization
    - Successfully migrated from Nuxt UI v3.3.0 to v4.0.0-alpha.1
    - Unified package with Pro components now included for free in the base package
    - Component API updates with new props, slots, and improved developer experience
    - Enhanced TypeScript support with better type definitions and IntelliSense
    - New styling system with improved theming and customization capabilities
    - Verified all existing components work correctly with new version
    - Maintained UI consistency while gaining access to new features
  - **Architecture Benefits:**
    - Modern tech stack with latest Nuxt 4.1.1 and cutting-edge features
    - Enhanced UI library with Pro components and superior TypeScript support
    - Clear organization eliminating confusion between workflow and management concerns
    - Significant performance improvements through import maps, lazy hydration, and route optimizations
    - Future-ready foundation with access to experimental features and latest web technologies
    - Proven patterns ready for simple, working translation management implementation
  - **Translation Management System:** Complete CRUD implementation following proven patterns
    - **Backend Commands:** Full CRUD operations in `src-tauri/src/commands/translations.rs`
      - `list_translations()` - List with filtering and pagination support  
      - `get_translation()` - Get single translation by ID
      - `update_translation()` - Update translation text and status
      - `delete_translation()` - Delete single translation
      - `bulk_delete_translations()` - Bulk deletion operations
      - `get_translation_stats()` - Project and global statistics
    - **Frontend State Management:** Complete store and composable implementation
      - `app/stores/translations.ts` - Pinia store for state management
      - `app/composables/useTranslations.ts` - UI logic with filtering, pagination, and actions
    - **UI Components:** Full-featured interface following Nuxt UI v4 patterns
      - `TranslationView.vue` - Advanced table with search, filtering, bulk operations
      - `TranslationForm.vue` - Modal form for editing translations with validation
      - `app/pages/translations.vue` - Complete page with statistics and navigation
    - **Integration:** Seamless navigation and user experience
      - Added "Translations" link to main navigation in AppHeader.vue
      - Status badges with color coding (NotTranslated, MachineTranslated, HumanReviewed, Ignored)
      - Responsive design with proper empty states and loading indicators
    - **Quality Assurance:** Production-ready implementation
      - All TypeScript linting errors resolved
      - Frontend builds successfully without warnings  
      - Backend compiles correctly with all commands registered
      - Following established patterns from proven glossary implementation

### Previous Additions
- **Phase 4: Code Organization - COMPLETED**
  - **Backend Renames:** Renamed `translation.rs` → `translator.rs` for clarity and consistency
  - **Frontend Renames:** Renamed `translate.ts` → `translator.ts` and `useTranslation.ts` → `useTranslator.ts`
  - **Import Updates:** Updated all imports and references across 12 files for consistency
  - **Testing Validation:** Verified builds work correctly after all renames
  - **Naming Convention:** Established clear distinction between `translator.*` (workflow) vs `translations.*` (CRUD management)
- **Phase 3: Smart Project Loading & Export System - COMPLETED**
  - **Engine-Agnostic Export System**: Factory pattern-based export with `reconstruct_text_unit_id()` method in Engine trait
  - **Database-Driven Injection**: Direct database queries for translated units using `find_translated_units_for_export()`
  - **Fixed Export Location**: Always exports to `project/ludolingua/` folder with proper file structure
  - **Open-Closed Principle**: Adding new engines requires only implementing `reconstruct_text_unit_id()` method
  - **Manifest Validation**: Export uses correct manifest hash for project identification
  - **User Feedback**: Toast notifications for export success/error states
  - **File Integrity**: Original project files remain unchanged during export process
  - **Working Export for RPG Maker MV & MZ**: Tested and verified functional
- **Major Code Cleanup & Architecture Improvements**
  - **33% function reduction in `engine.rs`** (450 → 344 lines, 24% size reduction)
  - **14% line reduction in `handler.rs`** (222 → 217 lines, 2.5% reduction)
  - **Unified database functions**: Consolidated duplicate loading functions into single `load_translations_from_database`
  - **Standardized error handling**: Manual AppError→String conversion with consistent patterns
  - **Clean architecture**: Perfect Open-Closed Principle implementation with factory-managed dispatch
  - **DRY principle applied**: Eliminated code duplication with helper functions
- **Smart Project Loading System**
  - **Manifest-aware loading**: Automatic detection of fresh vs existing projects
  - **Zero manual steps**: Removed "Load Saved" button and automatic routing
  - **Status-based routing**: Automatic component selection based on translation status
  - **100% smart loading capacity**: Handles all translation states seamlessly
  - **Database persistence**: All translations saved immediately to SQLite
  - **Fallback logic**: Graceful handling when database is empty or corrupted
- **Comprehensive Codebase Cleanup**
  - **Removed unused LLM services**: groq, openai, openrouter completely removed
  - **Cleaned up provider factory**: Only supports Ollama and RunPod
  - **Removed unused token estimation**: Moved `ActualTokenUsage` to translation.rs
  - **Cleaned up common.rs**: Removed unused Wolf RPG functions (307 lines removed)
  - **Updated mod.rs files**: Removed all references to deleted modules
  - **Frontend store cleanup**: Removed references to deleted LLM providers
- **Phase 4: Production Readiness - CURRENT FOCUS**
  - **Error Handling & Reliability**: Comprehensive error recovery mechanisms
  - **Database connection failure handling**: Partial export failure rollback
  - **Cross-platform compatibility validation**: Network timeout handling for remote LLM servers
  - **Performance Optimization**: Large project handling (1000+ files)
  - **Memory usage optimization**: Export progress indicators
  - **Background processing**: LLM request batching and rate limiting
  - **User Experience Enhancement**: Export history tracking, bulk export options, advanced filtering
  - **Better loading states**: Export format customization, advanced filtering and search
 - Backend/Manifest: Translation statistics tracking in `.ludolingua.json`
   - Added `total_text_units` and `translated_text_units` fields to `ProjectManifest` struct
   - Automatic manifest updates after text extraction (total count) and translation (translated count)
   - Manifest preserves statistics when recreated due to configuration changes
   - Frontend displays translation progress using manifest statistics
 - Backend/Manifest: Critical manifest hash mismatch fix
   - Fixed translations not loading due to manifest hash format mismatch
   - Removed old manifest hash format support (only uses new SHA hash format)
   - Updated `translate_text_unit` to use correct manifest hash from engine info
   - Simplified manifest system with single consistent hash format
 - Backend/Export: Complete export functionality for RPG Maker MV & MZ engines
   - Implemented engine-agnostic export system using factory pattern
   - Added `reconstruct_text_unit_id()` method to Engine trait for extensible export
   - Created `find_translated_units_for_export()` function for efficient database queries
   - Fixed export location to `project/ludolingua/` folder with proper file structure
   - Added toast notifications for export success/error feedback
   - Tested and verified working export for both MV and MZ engines
   - Open-Closed Principle compliance: new engines need only implement `reconstruct_text_unit_id()`
 - Backend/LLM: Groq integration for ultra-fast translation processing
   - Added `groq` feature to `llm` crate in `src-tauri/Cargo.toml`
   - Created `src-tauri/src/llm/services/groq.rs` using `LLMBuilder` with `LLMBackend::Groq`
   - Added `ProviderKind::Groq` to enum and factory instantiation
   - Created `src-tauri/models/groq.json` with popular models including Llama 3.1 70B, Mixtral 8x7B, and Gemma 2 9B
   - Updated provider commands to load Groq models from JSON catalog
   - Added Groq to available providers in frontend provider store
   - Updated settings page to handle Groq's fixed API endpoint (clears base_url automatically)
   - Provides 500+ tokens/second processing speed with 14,400 requests/day free tier
 - Backend/LLM: OpenRouter native API implementation
   - Created dedicated `src-tauri/src/llm/services/openrouter.rs` with direct HTTP calls using `reqwest`
   - Follows [OpenRouter API specification](https://openrouter.ai/docs/api-reference/overview) without `graniet/llm` dependency
   - Implements proper HTTP headers (`HTTP-Referer`, `X-Title`) per OpenRouter quickstart guide
   - Enhanced error handling with OpenRouter-specific error response parsing
   - Added `ProviderKind::Openrouter` to enum and factory support
   - Created `src-tauri/models/openrouter.json` with free and paid models (GPT-4o, Claude, Llama, Gemini)
   - Updated provider commands to load OpenRouter models from JSON catalog
 - Frontend/Settings: OpenRouter provider support
   - Added OpenRouter to available providers in provider store
   - OpenRouter appears as selectable provider in settings with model dropdown
   - Supports free models like `openai/gpt-oss-20b:free` and `meta-llama/llama-3.1-8b-instruct:free`
 - Backend/Engines: Experimental Wolf RPG support (Windows-only)
   - New `EngineType::WolfRpg`, factory detection via presence of `Data/`
   - Orchestrates external tools: UberWolfCli (optional decrypt) + WolfTL (create dump / patch)
   - Extracts strings from `dump/*.json` with stable JSON-pointer IDs and injects back before patching
   - Tools are expected in `src-tauri/src/engines/wolf_rpg/exe/` during dev; can be overridden via `LUDOLINGUA_WOLF_TOOLS`
 - Backend/Common: JSON walker helpers to collect/apply text units (`wolf_json:<dump_rel>#<pointer>`)
 - Frontend/Translation: Add "Add to glossary" action in results, mapping PromptType → Category
 - Backend/LLM: Apply Ollama `ModelOptions` for generation (`temperature`, `num_predict` aka max_tokens) so settings affect outputs.
 - Settings: Presets for Temperature/Max Tokens (Recommended, High, Creative) in `app/pages/settings.vue`.
 - About: LLM Parameters card and Performance & Hardware guidance in `AboutTechnology.vue`.
 - About: Tabbed navigation in `app/pages/about.vue` (What/Features/Technology/Glossary).
 - Backend/Text Processing: Preserve significant whitespace via placeholders in translation flow
   - Encode full-width spaces into `[FWSPC_n]`, ASCII space runs (leading/trailing or len≥2) into `[SPC_n]`, and tabs into `[TAB_n]`
   - Decode placeholders on injection to restore exact spacing
   - Integrated into `replace_formatting_codes_for_translation` and `restore_formatting_codes_after_translation`
 - Developer documentation: Added concise Rustdoc to core backend modules and TSDoc to main frontend stores
  to clarify responsibilities and data flow without changing behavior.
 - Backend/LLM: Multi-provider architecture with OpenAI support
   - `core/provider.rs`: `ProviderKind` enum and `LlmService` trait
   - `llm/factory.rs`: `create_service(LlmConfig)` selects provider (Ollama/OpenAI)
   - `llm/services/openai.rs`: OpenAI via `LLMBuilder` (api_key, model, temperature, max_tokens)
   - `commands/provider.rs`: `get_provider_models` loads `models/{provider}.json`
   - `models/openai.json`: Model metadata with pricing and context windows
 - Frontend/Settings: Provider selector and provider-specific model lists
   - `components/settings/ProviderSelector.vue` (provider + model)
   - `stores/provider.ts` (load providers, models, test)
 - Frontend/Token Estimation: Pre-run project token and cost estimate
   - `useTranslation.estimateTokens()` and `ProjectStats.vue` token card
 - Backend/Token Estimation: `utils/token_estimation.rs` + Tauri command; uses `ModelInfo.pricing`

### Changed
- **Translation Management UX:** Simplified interface for focused user experience
  - Streamlined filter grid from 5 to 4 columns for better space utilization
  - Removed project filter and project loading functionality from translation management
  - Focused on core translation management tasks (search, status filtering, type filtering)
  - Improved interface clarity by removing potentially confusing project switching
- **LLM Crate Migration:** Complete migration from `ollama-rs` to unified `llm` crate for better extensibility
  - **Dependencies:** Replaced `ollama-rs = "0.3.2"` with `llm = { version = "1.2.4", features = ["ollama"] }`
  - **OllamaService Migration:** Updated `src/llm/services/ollama.rs` to use `llm` crate's `LLMBuilder` pattern with `LLMBackend::Ollama`
  - **API Integration:** Implemented proper configuration builder with model, temperature, max_tokens, and base_url support
  - **Response Handling:** Fixed ChatResponse text extraction using Display trait implementation (`format!("{}", response)`)
  - **Backward Compatibility:** Maintained all existing methods and functionality (generate, test_connection, config_matches)
  - **Future-Ready:** Prepared foundation for easy addition of multiple LLM providers (OpenAI, Anthropic, DeepSeek, etc.)
  - **Type Safety:** Enhanced with `Box<dyn LLMProvider>` for unified provider interface
 - Backend/LLM State: `LlmState` now stores `Box<dyn LlmService>` and rebuilds on config change
 - Backend/Translation: Retry logic now stops immediately on fatal provider `insufficient_quota`
 - Backend/OpenAI: `test_connection` treats HTTP 429 as reachable, but reports `insufficient_quota` as not connected
 - Backend/OpenAI: Base URL normalization (strip trailing `/v1`); base URL optional
 - Frontend/Settings: Save `base_url` only for Ollama; clear for OpenAI automatically

### Fixed
- **Translation Management Row Selection:** Fixed non-functional row selection using official Nuxt UI v4 patterns
  - Corrected table binding from `v-model:selected` to `v-model:row-selection` per official documentation
  - Fixed selection state management using `rowSelection` ref and `useTemplateRef` for table access
  - Resolved TypeScript errors in selection counter and row access functions
  - Fixed checkbox implementation using proper `h()` render functions with correct props
  - Corrected table API access for selected row retrieval and bulk operations
  - Ensured bulk delete functionality works reliably with proper selection clearing
- OpenAI: Avoid 404/RelativeUrl errors by normalizing optional base URL and leaving it empty by default
 - Frontend/Translation: Abort batch early with clear toast when OpenAI reports `insufficient_quota`
 - Provider model loading: `get_provider_models` resolves `openai.json` correctly
 - Backend/Manifest: Fixed manifest hash mismatch causing "No translations found" error
  - Translations were saved with old format hash (`project_/path`) but queried with new format hash (SHA)
  - Updated `translate_text_unit` to use correct manifest hash from engine info instead of hardcoded format
  - Removed old manifest hash format support for consistency
  - Simplified manifest system to use single SHA hash format
- Backend/Manifest: Fixed manifest statistics preservation
  - Manifest now preserves `total_text_units` and `translated_text_units` when recreated
  - Statistics are maintained across project configuration changes
  - Automatic updates after text extraction and translation completion
- Backend/Engines: Fixed "Engine does not support extracting game data files" when loading MZ projects by adding MZ-specific dispatch in `commands/engine.rs`.
- Frontend/Translation UX: Fixed double-wrapped refs in `app/composables/useTranslation.ts` causing incorrect busy/progress rendering.
- Frontend/Batch Cancel: Batch translation now respects cancellation by checking `isTranslating` inside the loop in `app/stores/translate.ts`.
- Frontend/Translation: `translate_text_unit` invoke now passes snake_case keys (`text_unit`, `engine_info`) and uses `settingsStore.providerConfig` (temperature/max_tokens) instead of provider defaults.
- Defaults: Adjusted Ollama defaults to conservative translation values (temperature 0.3, max_tokens 256).
- Frontend/Translation: Add backward-compat invoke payload keys (`textUnit`, `engineInfo`) to tolerate older backend builds.
- Settings/ConnectionTester: Connection test now uses current settings config (`providerConfig`) instead of static defaults.
- ProjectStats: Simplified Token Settings (show Temperature + Max Tokens only); removed noisy token estimates.
- AboutTechnology: Replaced unavailable components with Tailwind grid and `USeparator`.
- GlossaryTable: Removed "All languages" option in language filters.
- Accessibility: Updated `GlossaryForm.vue` and `TranslationEditor.vue` modals to use `#title`/`#description`/`#actions`.
- Backend/Storage: SQLite glossary database is now stored under the OS app data directory via Tauri path resolver instead of the process working directory.
  - Prevents write failures in packaged apps (read-only bundles, Program Files on Windows).
  - Path examples: Windows `%AppData%/LudoLingua/ludolingua.db`, macOS `~/Library/Application Support/LudoLingua/ludolingua.db`, Linux `~/.local/share/LudoLingua/ludolingua.db`.
  - Existing dev DB files in `src-tauri/ludolingua.db*` are no longer used.
- Roadmap/Planning: Deferred backend stability items (LLM rate limiting, translation cache, auto-backup) from Phase 7 to Phase 8.0; and frontend batch groundwork to Phase 8.3. Updated `TODO.md`, `ROADMAP.md`, and `PROGRESS.MD` accordingly.
- Backend/LLM: Introduced managed shared state for Ollama client and lightweight rate limiting.
  - Added `LlmState` (shared `OllamaService` + `Semaphore`) and registered it in `lib.rs`.
  - Refactored `translate_text_unit` to use `State<LlmState>` and added `translate_with_retry` (timeout + retries).
  - Simplified `OllamaService` with low-level `generate(prompt)`; `translate` kept temporarily as a wrapper.
  - Observed stable keep-alive: single connection init then steady completions during batch.
- **Prompt Loading Robustness & DRY Runtime:**
  - Embedded prompt templates in production builds to avoid filesystem path issues
  - Kept filesystem loading in dev for easy iteration
  - Moved `PromptType` → template path mapping onto the enum itself
  - Filter `vocabularies.txt` by prompt type to reduce token usage and duplication
  - Cleaned duplicate `#[allow(dead_code)]` attributes in Ollama service
- **Language Catalog:**
  - Added `src-tauri/models/language.json` catalog (id, label, native_name, dir, enabled)
  - New backend command `get_languages` returns enabled languages from embedded JSON
  - Frontend `language` store now loads languages from backend and applies RTL via `dir` on `<html>`
  - Unified type: single `Language` model across BE/FE (removed separate catalog type)
- **Prompt Placeholder Standardization:**
  - Replaced RPG Maker percent parameters `%n` with bracketed `[ARG_n]` in prompts
  - Standardized newline examples to use `[NEWLINE_1]` token instead of literal line breaks in examples
  - Added `[NEWLINE_n]` to preserved token list in `prompts/basic.txt`
  - Updated examples in `dialogue.txt`, `equipment.txt`, `skill.txt`, `class.txt`, and `state.txt` to reflect new tokens

- **LLM Architecture Simplification (Ollama-only):**
  - Removed multi-provider abstraction (trait + factory); direct `OllamaService` calls
  - Simplified `LlmConfig` to Ollama-only fields; removed `Provider` enum and extra fields
  - Renamed command to `get_ollama_models`; removed `get_available_providers`
  - Frontend refactor to `OllamaConfig`; removed provider selector UI; invokes updated

- **Framework Migration to Nuxt 4 + pnpm:** Complete migration to latest technologies
  - **Nuxt 4 Upgrade:** Migrated from Nuxt 3.18.1 to Nuxt 4.0.3 with all latest features
  - **pnpm Package Manager:** Switched from npm to pnpm for better performance and dependency resolution
  - **Directory Structure Migration:** Automatically migrated to new Nuxt 4 `app/` directory structure using official codemod
  - **Pinia Integration:** Resolved Pinia initialization issues with manual plugin setup for better compatibility
  - **Build System Updates:** Updated all dependencies, TypeScript configurations, and build processes
  - **Development Experience:** Enhanced development workflow with better TypeScript support and modern architecture
- **Complete RPG Maker MV File Support:** Successfully implemented support for all 7 major RPG Maker MV data files
  - **Items.json Support:** Complete implementation for RPG Maker MV Items.json file parsing and translation
    - Added `src/engines/rpg_maker_mv/files/items.rs` with `Item` struct and translatable fields
    - Implemented `extract_text` and `inject_translations` functions for Items.json
    - Updated engine to detect and process Items.json alongside Actors.json
    - Added proper ID prefixing (`item_`) for text unit identification
  - **Skills.json Support:** Complete implementation for RPG Maker MV Skills.json file parsing and translation
    - Added `src/engines/rpg_maker_mv/files/skills.rs` with `Skill` struct and translatable fields
    - Implemented `extract_text` and `inject_translations` functions for Skills.json
    - Updated engine to detect and process Skills.json alongside Actors.json and Items.json
    - Added proper ID prefixing (`skill_`) for text unit identification
    - Supports extraction of skill names, descriptions, messages, and notes
  - **Weapons.json Support:** Complete implementation for RPG Maker MV Weapons.json file parsing and translation
    - Added `src/engines/rpg_maker_mv/files/weapons.rs` with `Weapon` struct and translatable fields
    - Implemented `extract_text` and `inject_translations` functions for Weapons.json
    - Updated engine to detect and process Weapons.json alongside other file types
    - Added proper ID prefixing (`weapon_`) for text unit identification
    - Supports extraction of weapon names, descriptions, and notes
  - **Armors.json Support:** Complete implementation for RPG Maker MV Armors.json file parsing and translation
    - Added `src/engines/rpg_maker_mv/files/armors.rs` with `Armor` struct and translatable fields
    - Implemented `extract_text` and `inject_translations` functions for Armors.json
    - Updated engine to detect and process Armors.json alongside other file types
    - Added proper ID prefixing (`armor_`) for text unit identification
    - Supports extraction of armor names, descriptions, and notes
      - **Classes.json Support:** Complete implementation for RPG Maker MV Classes.json file parsing and translation
    - Added `src/engines/rpg_maker_mv/files/classes.rs` with `Class` struct and translatable fields
    - Implemented `extract_text` and `inject_translations` functions for Classes.json
    - Updated engine to detect and process Classes.json alongside other file types
    - Added proper ID prefixing (`class_`) for text unit identification
    - Supports extraction of class names and notes
    - **System.json Support:** Complete implementation for RPG Maker MV System.json file parsing and translation
    - Added `src/engines/rpg_maker_mv/files/system.rs` with `System` and `Terms` structs for complex nested structure
    - Implemented custom `extract_text` and `inject_translations` functions for System.json's unique single-object structure
    - Updated engine to detect and process System.json alongside other file types
    - Added proper ID prefixing (`system_`) for text unit identification
    - Supports extraction of game title, currency unit, armor types, elements, equipment types, skill types, weapon types, switches, variables, and UI terms/messages
    - Handles complex nested structure with terms object containing basic, commands, params, and messages arrays
    - Fixed System.json message translation to use correct prompt type (System instead of Other) for proper system text handling
    - **States.json Support:** Complete implementation for RPG Maker MV States.json file parsing and translation
    - Added `src/engines/rpg_maker_mv/files/states.rs` with `State` struct and translatable fields
    - Implemented `extract_text` and `inject_translations` functions using common helper functions
    - Updated engine to detect and process States.json alongside other file types
    - Added proper ID prefixing (`state_`) for text unit identification
    - Supports extraction of status effect names, descriptions, battle messages, and developer notes
    - Created specialized `state.txt` prompt file for RPG status effect translation
    - Added `PromptType::State` enum variant for status effect-specific translation guidance
    - Handles complex array structure with null values and empty states filtering
    - Enhanced `state.txt` prompt with better battle message examples and stricter output formatting
    - **Enemies.json Support:** Complete implementation for RPG Maker MV Enemies.json file parsing and translation
    - Added `src/engines/rpg_maker_mv/files/enemies.rs` with `Enemy` struct and translatable fields
    - Implemented `extract_text` and `inject_translations` functions using common helper functions
    - Updated engine to detect and process Enemies.json alongside other file types
    - Added proper ID prefixing (`enemy_`) for text unit identification
    - Supports extraction of enemy names and developer notes
    - Handles complex array structure with null values and empty enemies filtering
- **CommonEvents.json Support:** Complete implementation for RPG Maker MV CommonEvents.json file parsing and translation
- Added `src/engines/rpg_maker_mv/files/common_events.rs` with `CommonEvent` and `EventCommand` structs
- Implemented `extract_text` and `inject_translations` functions using common helper functions
- Updated engine to detect and process CommonEvents.json alongside other file types
- Added proper ID prefixing (`common_event_`) for text unit identification
- Supports extraction of event names, message content (code 401), comments (code 108), and other translatable parameters
- Handles complex event command structure with nested parameters and command codes
- Used appropriate prompt types (Character for names, Dialogue for messages, Other for comments and parameters)
- Handles complex array structure with null values and empty events filtering
- **MapInfos.json Support:** Complete implementation for RPG Maker MV MapInfos.json file parsing and translation
- Added `src/engines/rpg_maker_mv/files/maps_infos.rs` with `MapInfo` struct and translatable fields
- Implemented `extract_text` and `inject_translations` functions using common helper functions
- Updated engine to detect and process MapInfos.json alongside other file types
- Added proper ID prefixing (`map_info_`) for text unit identification
- Supports extraction of map names from the map tree/structure file
- Handles complex array structure with null values and empty map entries filtering
- Used appropriate prompt types (Character for map names)
- Distinguished between MapInfos.json (map metadata) and MapXXX.json (map content) files
- **MapXXX.json Support:** Complete implementation for RPG Maker MV MapXXX.json file parsing and translation with dynamic file discovery
- Added `src/engines/rpg_maker_mv/files/maps.rs` with comprehensive data structures for Map, MapEvent, EventPage, and EventCommand
- Implemented dynamic file discovery to automatically handle Map001.json, Map002.json, etc.
- Added `extract_text` and `inject_translations` functions following the established architecture pattern
- Updated engine to include dynamic MapXXX.json discovery and processing
- Added proper ID prefixing (`map_event_`) for text unit identification
- Supports extraction of event names, notes, messages (code 401), and comments (code 108) from map events
- Handles complex nested structure with events, pages, and commands
- Used appropriate prompt types (Character for event names, Dialogue for messages, Other for notes/comments)
- Robust error handling with graceful fallback for individual map files
- Dynamic file discovery eliminates need for hardcoded map file lists
- **Enhanced Prompt System:** Comprehensive prompt architecture optimization for better translation quality
  - **Streamlined Base Prompt:** Created `basic.txt` as optimized base prompt (removed overwhelming examples)
  - **Unified Equipment Prompts:** Consolidated `weapon.txt` and `item.txt` into unified `equipment.txt`
  - **Specific Translation Guides:** Added mandatory translation mappings to all prompt files for consistency
  - **Enhanced Output Format:** Improved instructions to prevent unwanted comments, prefixes, and metadata
  - **Field-Specific Guidelines:** Added tailored instructions for character names, equipment, skills, and classes
  - **Erotic Content Handling:** Enhanced terminology and examples for adult game content translation
  - **Organized Dialogue Examples:** Moved dialogue-specific examples from `basic.txt` to `dialogue.txt` for better organization
  - **Flexible Skill Guidelines:** Replaced rigid skill message mappings with flexible pattern-based guidelines
  - **Enhanced Class Translations:** Improved RPG class distinctions (勇者 → Hero, 戦士 → Warrior)
- **Improved Debugging & Monitoring:** Enhanced application monitoring and debugging capabilities
  - **Project Statistics Enhancement:** Added language configuration display to `ProjectStats.vue`
  - **Translation Quality Monitoring:** Added comprehensive logging to `TranslationView.vue` for translation debugging
  - **Settings Store Improvements:** Enhanced provider store with proper initialization and settings loading
  - **Configuration Display:** Added AI and language configuration logging for troubleshooting
- **Enhanced User Interface:** Improved user experience with better workflow and usability features
  - **Load New Project:** Added "Load New Project" button to main page header for easy project switching
  - **Reset Functionality:** Added "Reset" button to TranslationView for clearing all translations
  - **Enhanced Button States:** Improved button availability logic (Inject only when translation finished)
  - **Better Progress Tracking:** Enhanced translation progress indicators and status management
  - **Improved User Experience:** Streamlined project loading workflow with better feedback

### Changed
- **Framework Architecture:** Complete migration to Nuxt 4 with modern development practices
  - **Package Manager:** Switched from npm to pnpm for improved performance and dependency management
  - **Directory Structure:** Migrated to new Nuxt 4 `app/` directory structure for better organization and performance
  - **Pinia Integration:** Manual Pinia initialization for better control and compatibility
  - **Build System:** Updated to latest Nuxt 4 build system with enhanced TypeScript support
  - **Development Workflow:** Improved development experience with modern tooling and architecture
- **Common Helper Functions Architecture:** Refactored engine implementation to use reusable helper functions
  - Created `src/engines/common.rs` with generic `extract_file_type_text` and `inject_file_type_translations` functions
  - Updated RPG Maker MV engine to use common helper functions instead of private implementations
  - Eliminated code duplication between engine implementations
  - Improved maintainability and consistency across all file types
  - Made it easier to add new file types (just 3 lines of code per file type)
  - Enhanced type safety with proper generic function signatures
- **Advanced Common Functions Architecture:** Further refactored file modules to use higher-level abstraction functions
  - Created `src/engines/rpg_maker_mv/files/common.rs` with `extract_text_from_file_with_objects` and `inject_translations_into_file_with_objects` functions
  - Refactored all file modules (`actors.rs`, `items.rs`, `skills.rs`, `weapons.rs`, `armors.rs`, `classes.rs`) to use new common functions
  - Achieved ~70% reduction in code duplication across file modules
  - File-specific modules now focus only on their unique data structures and field logic
  - Eliminated boilerplate code for file existence checks, JSON parsing, and iteration
  - Improved maintainability and readability of all file processing code
- **Prompt System Architecture:** Comprehensive prompt system optimization and consolidation
  - **Consolidated Equipment Prompts:** Merged `weapon.txt` and `item.txt` into unified `equipment.txt` for better consistency
  - **Updated PromptType Enum:** Replaced separate `Weapon` and `Item` types with unified `Equipment` type
  - **Streamlined Base Prompt:** Created `basic.txt` as optimized base prompt, removing overwhelming examples
  - **Enhanced Translation Quality:** Added mandatory translation mappings and improved output format instructions
  - **Field-Specific Optimization:** Added tailored guidelines for different text types (character names, equipment, skills, etc.)
  - **Improved LLM Integration:** Updated `PromptBuilder` and file parsers to use new consolidated prompt system
  - **Organized Dialogue Examples:** Moved dialogue-specific examples from `basic.txt` to `dialogue.txt` for better organization
  - **Flexible Skill Guidelines:** Replaced rigid skill message mappings with flexible pattern-based guidelines for better cross-game compatibility
  - **Enhanced Class Translations:** Improved RPG class distinctions with proper translations (勇者 → Hero, 戦士 → Warrior)
- **User Interface Enhancements:** Improved user experience and workflow
  - **Project Management:** Added "Load New Project" functionality for easy project switching
  - **Translation Workflow:** Enhanced TranslationView with Reset button and improved button states
  - **Progress Tracking:** Better translation progress indicators and status management
  - **User Feedback:** Improved loading states, error handling, and visual feedback

### Technical Improvements
- **Framework Migration:** Successfully migrated to Nuxt 4 + pnpm with enhanced performance and modern architecture
- **Package Management:** Improved dependency resolution and installation speed with pnpm
- **Directory Structure:** Better organization with new Nuxt 4 `app/` directory structure for improved IDE support
- **Pinia Compatibility:** Resolved initialization issues for better state management
- **Build Performance:** Enhanced build system with latest Nuxt 4 optimizations
- **Development Experience:** Modern development workflow with better TypeScript support and tooling
- **Engine Architecture:** Reduced code complexity by ~100 lines through common helper functions
- **Error Handling:** Consistent error handling and logging across all file types
- **Reusability:** Common functions can be used across different RPG Maker versions (MV, MZ, etc.)
- **Type Safety:** Enhanced generic function implementations with proper error handling
- **File Module Architecture:** Achieved ~70% code reduction in file modules through advanced common functions
- **Code Maintainability:** File-specific modules now focus only on unique data structures and field logic
- **Boilerplate Elimination:** Removed repetitive file I/O, JSON parsing, and iteration code from all file modules
- **Prompt System Optimization:** Streamlined prompt architecture with ~50% reduction in prompt complexity
- **Translation Quality Enhancement:** Eliminated LLM output inconsistencies through mandatory translation mappings
- **Debugging Capabilities:** Enhanced monitoring and debugging tools for better translation quality assessment
- **Settings Management:** Improved settings store initialization and configuration display for better user experience
- **User Experience:** Enhanced workflow with better button states, progress tracking, and project management
- **Cross-Game Compatibility:** Flexible skill guidelines allow for different game styles and translation preferences
- **Prompt Organization:** Better separation of concerns with dialogue examples properly organized in dedicated files

## [0.2.0] - 2025-08-13

### Added
- Backend/Engines: RPG Maker MZ support (core files parity with MV)
  - `rpg_maker_mz/engine.rs` detects MZ and reuses MV modules with `data/*` paths
  - Implemented extraction/injection for: Actors, Classes, Items, Skills, Weapons, Armors, System, States, Enemies, CommonEvents, Troops, MapInfos, and MapXXX (event text)
  - Factory returns MZ engine; command layer dispatch updated

### Changed

### Fixed
- Backend/Engines: Fixed “Engine does not support extracting game data files” when loading MZ projects by adding MZ-specific dispatch in `commands/engine.rs`.

## [0.1.0] - 2024-01-XX

### Added
- Initial release with Actors.json translation support
- Basic RPG Maker MV project loading and text extraction
- AI translation integration with Ollama support
- Settings management and configuration persistence
- Translation workflow with status tracking and error handling
